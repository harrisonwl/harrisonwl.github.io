<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width">

        <title>William L. Harrison, Ph.D : Language Reference</title>
        <meta name="description" content="Center for High Assurance Computing">

        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
        <link rel="stylesheet" href="/css/syntax.css">
        <link rel="stylesheet" href="/css/main.css">
    </head>
    <body>

        <div class="container">
            <div class="row">
                <div id="header" class="col-sm-12">
                    <h4><a class="brand" href="/">William L. Harrison, Ph.D</a>
    <small>Center for High Assurance Computing</small>
</h4>

                </div>
            </div>

            <div class="row">
                
                
                    <div id="navigation" class="col-sm-2">
                        <ul class="nav nav-list">
    <li><a href="/">Home</a></li>
    
        
        

        
            
                <li class="nav-header"></li>
            
            <li data-order="1"><a href="/doc/publications.html">Publications</a></li>
        
            
            <li data-order="6"><a href="/doc/sha256.html">Case Study #2: SHA-256</a></li>
        
            
            <li data-order="5"><a href="/doc/crossbarswitch.html">Case Study #1: Crossbar Switch</a></li>
        
            
            <li data-order="4"><a href="/doc/language-reference.html">Language Reference</a></li>
        
            
            <li data-order="3"><a href="/doc/quick-start.html">Quick Start</a></li>
        
            
            <li data-order="2"><a href="/doc/installing-rewire.html">Installing ReWire</a></li>
        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
    
<!-- List additional links. It is recommended to add a divider
    e.g. <li class="divider"></li> first to break up the content. -->
</ul>

                    </div>

                    <div id="content" class="col-sm-10">
                        <div class="page-header">
    <h2>Language Reference
        
    </h2>
</div>

<p>The purpose of this section is to provide an overview of the ReWire language as it relates to vanilla Haskell. Readers unfamiliar with Haskell may wish to consult an introductory text such as <a href="http://www.cs.nott.ac.uk/~pszgmh/book.html">Programming in Haskell</a> by Graham Hutton or <a href="http://learnyouahaskell.com">Learn You a Haskell for Great Good!</a> by Miran Lipovaƒça before diving into ReWire.</p>

<p>ReWire is a <em>subset</em> of Haskell: all ReWire programs are Haskell programs, but not all Haskell programs are ReWire programs. The main difference between ReWire and Haskell is that ReWire places limits on the use of higher order functions, polymorphism, and recursion. Higher order functions and polymorphism are not allowed except where they can be eliminated via inlining. Recursion is only allowed for functions and computations in a certain class of monads, and such computations must be guarded and tail recursive.</p>

<h1 id="reactive-resumption-monads">Reactive Resumption Monads</h1>

<p>The fundamental abstraction in ReWire is a class of monads called <em>reactive resumption monads</em>. Reactive resumption monads allow us to give a functional semantics to clocked, reactive processes like hardware circuits.</p>

<p>While reactive resumption monads are treated as a primitive in ReWire, their semantics can be defined in terms of Haskell. We will start with a simple case, then generalize to a monad transformer. The type of the <em>reactive resumption monad</em> <code class="highlighter-rouge">Re</code> is defined in Haskell as follows.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Re</span> <span class="n">i</span> <span class="n">o</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Done</span> <span class="n">a</span>
              <span class="o">|</span> <span class="kt">Pause</span> <span class="n">o</span> <span class="p">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="kt">Re</span> <span class="n">i</span> <span class="n">o</span> <span class="n">a</span><span class="p">)</span>
</code></pre>
</div>

<p>Think of the type <code class="highlighter-rouge">Re i o a</code> as representing a computation that is exchanging input and output signals (of types <code class="highlighter-rouge">i</code> and <code class="highlighter-rouge">o</code> respectively) with an external environment, and will return a value of type <code class="highlighter-rouge">a</code> if and when it terminates. Formally, a computation in <code class="highlighter-rouge">Re i o a</code> is either in a <code class="highlighter-rouge">Done</code> state, representing a finished computation that has returned a value of type <code class="highlighter-rouge">a</code>, or in a <code class="highlighter-rouge">Pause</code> state, yielding an output of type <code class="highlighter-rouge">o</code> and a function (i.e., a continuation) of type <code class="highlighter-rouge">i -&gt; Re i o a</code> that is waiting for the next input from the environment. The type <code class="highlighter-rouge">Re i o</code> is a monad as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Re</span> <span class="n">i</span> <span class="n">o</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">return</span>          <span class="o">=</span> <span class="kt">Done</span>
  <span class="kt">Done</span> <span class="n">v</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span>    <span class="o">=</span> <span class="n">f</span> <span class="n">v</span>
  <span class="kt">Pause</span> <span class="n">o</span> <span class="n">k</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Pause</span> <span class="n">o</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=&gt;</span> <span class="n">f</span><span class="p">)</span>
</code></pre>
</div>

<p>where <code class="highlighter-rouge">&gt;=&gt;</code> is the left-to-right Kleisli composition operator.</p>

<p>We can generalize <code class="highlighter-rouge">Re</code> to a monad transformer <code class="highlighter-rouge">ReT</code>, which allows us to mix other kinds of effects with reactivity.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">newtype</span> <span class="kt">ReT</span> <span class="n">i</span> <span class="n">o</span> <span class="n">m</span> <span class="n">a</span> <span class="o">=</span>
        <span class="kt">ReT</span> <span class="p">{</span> <span class="n">deReT</span> <span class="o">::</span> <span class="n">m</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span> <span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">i</span> <span class="o">-&gt;</span> <span class="kt">ReT</span> <span class="n">i</span> <span class="n">o</span> <span class="n">m</span> <span class="n">a</span><span class="p">))</span> <span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">ReT</span> <span class="n">i</span> <span class="n">o</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">return</span> <span class="o">=</span> <span class="kt">ReT</span> <span class="o">.</span> <span class="n">return</span> <span class="o">.</span> <span class="kt">Left</span>
  <span class="kt">ReT</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">ReT</span> <span class="o">$</span> <span class="kr">do</span>
    <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">m</span>
    <span class="kr">case</span> <span class="n">r</span> <span class="kr">of</span>
      <span class="kt">Left</span> <span class="n">v</span>      <span class="o">-&gt;</span> <span class="n">deReT</span> <span class="p">(</span><span class="n">f</span> <span class="n">v</span><span class="p">)</span>
      <span class="kt">Right</span> <span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">k</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="kt">Right</span> <span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">k</span> <span class="o">&gt;=&gt;</span> <span class="n">f</span><span class="p">))</span>

<span class="kr">instance</span> <span class="kt">MonadTrans</span> <span class="p">(</span><span class="kt">ReT</span> <span class="n">i</span> <span class="n">o</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">lift</span> <span class="n">m</span> <span class="o">=</span> <span class="kt">ReT</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">return</span> <span class="o">.</span> <span class="kt">Left</span><span class="p">)</span>
</code></pre>
</div>

<p>One particularly useful operation in <code class="highlighter-rouge">ReT</code>, which we will actually take as a primitive in ReWire, is called <code class="highlighter-rouge">signal</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">signal</span> <span class="o">::</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">o</span> <span class="o">-&gt;</span> <span class="kt">ReT</span> <span class="n">i</span> <span class="n">o</span> <span class="n">m</span> <span class="n">i</span>
<span class="n">signal</span> <span class="n">o</span> <span class="o">=</span> <span class="kt">ReT</span> <span class="p">(</span><span class="n">return</span> <span class="p">(</span><span class="kt">Right</span> <span class="p">(</span><span class="n">o</span><span class="p">,</span><span class="n">return</span><span class="p">)))</span>
</code></pre>
</div>

<p>Think of <code class="highlighter-rouge">signal o</code> as meaning ‚Äúyield the output <code class="highlighter-rouge">o</code> to the environment, wait for a new input <code class="highlighter-rouge">i</code>, then return <code class="highlighter-rouge">i</code>‚Äù.</p>

<h1 id="layered-state-monads">Layered State Monads</h1>

<p>ReWire also contains built-in support for <em>layered state monads</em>, which enable us to describe circuits with mutable state. Formally, a layered state monad is any monad composed from one or more applications of the state monad transformer <code class="highlighter-rouge">StT</code> to the base identity monad <code class="highlighter-rouge">I</code>. While <code class="highlighter-rouge">StT</code> and <code class="highlighter-rouge">I</code> are primitives in ReWire, they can be defined in Haskell as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">newtype</span> <span class="kt">StT</span> <span class="n">s</span> <span class="n">m</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">StT</span> <span class="p">{</span> <span class="n">deStT</span> <span class="o">::</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">StT</span> <span class="n">s</span> <span class="n">m</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">return</span> <span class="n">x</span>    <span class="o">=</span> <span class="kt">StT</span> <span class="o">$</span> <span class="nf">\</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
  <span class="kt">StT</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">StT</span> <span class="o">$</span> <span class="nf">\</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">s</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">s</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">deStT</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span> <span class="n">s</span>

<span class="kr">instance</span> <span class="kt">MonadTrans</span> <span class="p">(</span><span class="kt">StT</span> <span class="n">s</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">lift</span> <span class="n">m</span> <span class="o">=</span> <span class="kt">StT</span> <span class="o">$</span> <span class="nf">\</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="nf">\</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>

<span class="kr">newtype</span> <span class="kt">I</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">I</span> <span class="p">{</span> <span class="n">deI</span> <span class="o">::</span> <span class="kt">I</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="p">}</span>

<span class="kr">instance</span> <span class="kt">Monad</span> <span class="kt">I</span> <span class="kr">where</span>
  <span class="n">return</span>    <span class="o">=</span> <span class="kt">I</span>
  <span class="kt">I</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
</code></pre>
</div>

<p>These are, in fact, equivalent to <code class="highlighter-rouge">StateT</code> and <code class="highlighter-rouge">Identity</code> in Haskell‚Äôs standard libraries.</p>

<p>The monads supported by ReWire are limited to monads composed of</p>

<h1 id="restrictions">Restrictions</h1>

<p>The ReWire language is essentially a subset of Haskell 98. The major restrictions are as follows.</p>

<ul>
  <li><strong>Type classes</strong> are not (yet) implemented.</li>
  <li>The <strong><code class="highlighter-rouge">type</code> keyword</strong> is not (yet) implemented.</li>
  <li><strong>Polymorphic</strong> and <strong>higher-order</strong> functions are only allowed if they can be <strong>eliminated via inlining</strong>.
    <ul>
      <li>For example, the polymorphic function <code class="highlighter-rouge">fst :: (a,b) -&gt; a</code> can always be inlined, as can the higher-order (and polymorphic) function <code class="highlighter-rouge">(.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; (a -&gt; c)</code>.</li>
    </ul>
  </li>
  <li><strong><code class="highlighter-rouge">Data</code> types</strong> are allowed, including parametric data types like <code class="highlighter-rouge">Maybe</code>, but only if they are <strong>first-order</strong> (i.e., do not contain any function- or monad-typed fields) and <strong>non-recursive</strong>.</li>
  <li><strong>Recursive function definitions</strong> are allowed, but only in a reactive resumption monad. Such definitions must be <em>tail recursive</em> and <em>guarded</em>.
    <ul>
      <li>FIXME: Insert some examples/nonexamples.</li>
    </ul>
  </li>
</ul>

<h1 id="interfacing-with-vhdl">Interfacing with VHDL</h1>

<ul>
  <li>Data types -&gt; bit vectors</li>
  <li><code class="highlighter-rouge">nativeVhdl</code></li>
  <li><code class="highlighter-rouge">extrude</code></li>
  <li><code class="highlighter-rouge">start</code></li>
  <li><code class="highlighter-rouge">signal</code></li>
</ul>


                    </div>
                
            </div>

            

            <div class="row">
                <div id="footer" class="col-sm-12">
                    Documentation for <a href="https://github.com/mu-chaco/ReWire">William L. Harrison, Ph.D</a>

                </div>
            </div>
        </div>

        <script>
            function orderNav() {
                var list,
                    section,
                    header,
                    sections = [],
                    lists = {},
                    headers = {};

                var navUl = document.querySelectorAll('#navigation ul')[0],
                    navLis = document.querySelectorAll('#navigation ul li');

                if (!navUl) return;

                for (var i = 0; i < navLis.length; i++) {
                    var order, li = navLis[i];

                    if (li.classList.contains('nav-header')) {
                        section = li.textContent || li.innerText;
                        sections.push(section);
                        headers[section] = li;
                        continue;
                    }

                    if (!lists[section]) {
                        lists[section] = [];
                    }

                    order = parseFloat(li.getAttribute('data-order'))
                    lists[section].push([order, li]);
                }

                for (var i = 0; i < sections.length; i++) {
                    section = sections[i];
                    list = lists[section].sort(function(a, b) {
                        return a[0] - b[0];
                    });

                    if (header = headers[section]) {
                        navUl.appendChild(header);
                    }
                    for (var j = 0; j < list.length; j++) {
                        navUl.appendChild(list[j][1]);
                    }
                }
            }

            if (document.querySelectorAll) orderNav();
        </script>
        
    </body>
</html>
