<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="viewport" content="width=device-width">

        <title>William L. Harrison, Ph.D : Case Study #2: SHA-256</title>
        <meta name="description" content="Center for High Assurance Computing">

        <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css" rel="stylesheet">
        <link rel="stylesheet" href="/css/syntax.css">
        <link rel="stylesheet" href="/css/main.css">
    </head>
    <body>

        <div class="container">
            <div class="row">
                <div id="header" class="col-sm-12">
                    <h4><a class="brand" href="/">William L. Harrison, Ph.D</a>
    <small>Center for High Assurance Computing</small>
</h4>

                </div>
            </div>

            <div class="row">
                
                
                    <div id="navigation" class="col-sm-2">
                        <ul class="nav nav-list">
    <li><a href="/">Home</a></li>
    
        
        

        
            
                <li class="nav-header"></li>
            
            <li data-order="1"><a href="/doc/publications.html">Publications</a></li>
        
            
            <li data-order="6"><a href="/doc/sha256.html">Case Study #2: SHA-256</a></li>
        
            
            <li data-order="5"><a href="/doc/crossbarswitch.html">Case Study #1: Crossbar Switch</a></li>
        
    
        
        

        
    
        
        

        
    
        
        

        
    
        
        

        
    
<!-- List additional links. It is recommended to add a divider
    e.g. <li class="divider"></li> first to break up the content. -->
</ul>

                    </div>

                    <div id="content" class="col-sm-10">
                        <div class="page-header">
    <h2>Case Study #2: SHA-256
        
    </h2>
</div>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>

<script type="text/javascript" async="" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
</script>

<h3 id="i-introduction">I. Introduction</h3>

<p>The SHA-2 (Secure Hash Algorithm) is a set of cryptographic hash functions designed by the National Security Agency and SHA-256 is one of these algorithms. These algorithms were defined semi-formally in documents produced by <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">NIST</a>.
Cryptographic algorithms are good candidates for hardware implementation because they typically possess components whose performance benefits from hardware acceleration. 
But they are also prime candidates for formal verification because of their critical role in maintaining security and integrity in a wide variety of systems.</p>

<p>This case study explores the model-driven design and synthesis of a hardware accelerator for the SHA-256 cryptographic hash function.
The approach is semantics-driven, starting from a reference semantics for SHA-256.
The whole derivation takes place within the Haskell functional language and so the hardware accelerator produced by the ReWire compiler is formally verifiable with respect to the reference semantics using equational reasoning in Haskell.</p>

<h5 id="overview"><strong>Overview</strong></h5>

<p>The development in this case study proceeds along the same lines as in <a href="/doc/crossbarswitch.html">Case Study #1</a>. That is, first we develop a reference semantics for SHA-256 in Haskell, show how to transform it into a ReWire implementation, and, finally, show how the resulting implementation is synthesized. The code that we make use of in this is as follows:</p>

<ul>
  <li><a href="/assets/code/sha256/ReWirePrelude.hs">ReWirePrelude.hs</a>: some standard definitions.</li>
  <li><a href="/assets/code/sha256/Reference256.hs">Reference256.hs</a>: the reference semantics for SHA-256 in Haskell.</li>
  <li><a href="/assets/code/sha256/TestHarness.hs">TestHarness.hs</a>: harness for testing specifications.</li>
  <li><a href="/assets/code/sha256/FirstImplementation.hs">FirstImplementation.hs</a> and <a href="/assets/code/sha256/SecondImplementation.hs">SecondImplementation.hs</a>: two derived implementations of SHA256 in Haskell.</li>
  <li><a href="/assets/code/sha256/RWFirstImplementation.hs">RWFirstImplementation.hs</a> and <a href="/assets/code/sha256/RWSecondImplementation.hs">RWSecondImplementation.hs</a>: two derived implementations of SHA256 in ReWire.</li>
  <li><a href="/assets/code/sha256/RWFirstImplementation.vhd">RWFirstImplementation.vhd</a> and <a href="/assets/code/sha256/RWSecondImplementation.vhd">RWSecondImplementation.vhd</a>: two VHDL implementations of SHA256 generated by the ReWire compiler.</li>
  <li><a href="/assets/code/sha256/Counter.hs">Counter.hs</a>, <a href="/assets/code/sha256/Globals256.hs">Globals256.hs</a>, <a href="/assets/code/sha256/MetaprogrammingRW.hs">MetaprogrammingRW.hs</a>, and <a href="/assets/code/sha256/prims.vhd">prims.vhd</a>: various and sundry files whose purpose will be explained along the way.</li>
  <li><a href="/assets/code/sha256/sha256-casestudy.tar.gz">Tarball of All This Code</a>.</li>
</ul>

<h3 id="ii-haskell-reference-semantics-for-sha-256">II. Haskell Reference Semantics for SHA-256</h3>

<h4 id="the-top-level"><strong>The Top Level</strong></h4>

<p>The input to the SHA-256 algorithm is assumed to be a sequence of bytes and its output is a <em>digest</em> of
eight 32-bit words. Respectively, these are represented in Haskell as the types <code class="highlighter-rouge">[Char]</code> (i.e., a list of ASCII characters) and <code class="highlighter-rouge">Oct Word32</code>.
A Haskell function implementing this algorithm, 
<code class="highlighter-rouge">refsha256</code>, is presented below; its type is <code class="highlighter-rouge">[Char] -&gt; Oct Word32</code>.
The function <code class="highlighter-rouge">refsha256</code> is the composition of functions <code class="highlighter-rouge">pad</code>, <code class="highlighter-rouge">sha256</code>, and <code class="highlighter-rouge">runM</code> which are discussed in more detail below.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">refsha256</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Oct</span> <span class="kt">Word32</span>
<span class="n">refsha256</span> <span class="o">=</span> <span class="n">runM</span> <span class="o">.</span> <span class="n">sha256</span> <span class="o">.</span> <span class="n">pad</span>

<span class="n">pad</span>    <span class="o">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Hex</span> <span class="kt">Word32</span><span class="p">]</span>
<span class="n">sha256</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Hex</span> <span class="kt">Word32</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">M</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">Word32</span><span class="p">)</span>
<span class="n">runM</span>   <span class="o">::</span> <span class="kt">M</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span>

<span class="kr">data</span> <span class="kt">Oct</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Oct</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span>
<span class="kr">data</span> <span class="kt">Hex</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Hex</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span> <span class="n">a</span>
</code></pre>
</div>

<p>The SHA-256 algorithm first pads the input sequence so that the result has length as a multiple of 512 bits.
The padded input is then parsed into 512 bit blocks, 
$M^{(1)},\ldots,M^{(N)}$. Each of these blocks, $M^{(i)}$, is further parsed into sixteen 32-bit words, 
$M_0^{(i)},\ldots,M_{15}^{(i)}$ and represented in Haskell with the type <code class="highlighter-rouge">Hex Word32</code>— thus, the type of the <code class="highlighter-rouge">pad</code> function. The code for <code class="highlighter-rouge">pad</code> (as well as for <code class="highlighter-rouge">runM</code>) is found in <code class="highlighter-rouge">TestHarness.hs</code>; their definitions would not be illuminating here.</p>

<p>The function <code class="highlighter-rouge">sha256</code> implements the main loop of the SHA-256 algorithm. It takes the sequence of blocks formatted by <code class="highlighter-rouge">pad</code> (i.e., a list of type <code class="highlighter-rouge">Hex Word32</code>) as input and produces a computation of a digest (i.e., a computation of type <code class="highlighter-rouge">M (Oct Word32)</code>) as output. Here, <code class="highlighter-rouge">M</code> is a <em>monad</em>, which is a construction used for representing side-effects in the pure functional language Haskell. We define <code class="highlighter-rouge">M</code> and its use below.</p>

<h4 id="testing-against-the-nist-standard"><strong>Testing Against the NIST Standard</strong></h4>

<p>The NIST document defining SHA-256 provides three example hash computations against which one may test implementations of the algorithm. The transcript below summarizes the tests applied to <code class="highlighter-rouge">refsha256</code>. The tests apply <code class="highlighter-rouge">refsha256</code> to messages <code class="highlighter-rouge">msg1</code>, <code class="highlighter-rouge">msg2</code>, and <code class="highlighter-rouge">msg3</code>; <code class="highlighter-rouge">msg1</code> is just <code class="highlighter-rouge">"abc"</code> while the other two are too long to print easily here.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">ghci</span><span class="o">&gt;</span> <span class="n">refsha256</span> <span class="n">msg1</span>
  <span class="kt">Oct</span> <span class="mi">3128432319</span> <span class="mi">2399260650</span> <span class="mi">1094795486</span> <span class="mi">1571693091</span> 
      <span class="mi">2953011619</span> <span class="mi">2518121116</span> <span class="mi">3021012833</span> <span class="mi">4060091821</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">hashed1</span>
  <span class="kt">Oct</span> <span class="mi">3128432319</span> <span class="mi">2399260650</span> <span class="mi">1094795486</span> <span class="mi">1571693091</span> 
      <span class="mi">2953011619</span> <span class="mi">2518121116</span> <span class="mi">3021012833</span> <span class="mi">4060091821</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">refsha256</span> <span class="n">msg2</span>
  <span class="kt">Oct</span> <span class="mi">613247585</span> <span class="mi">3523623096</span> <span class="mi">3854575251</span> <span class="mi">205414457</span> 
      <span class="mi">2738676825</span> <span class="mi">1694441831</span> <span class="mi">4142722516</span> <span class="mi">433784513</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">hashed2</span>
  <span class="kt">Oct</span> <span class="mi">613247585</span> <span class="mi">3523623096</span> <span class="mi">3854575251</span> <span class="mi">205414457</span> 
      <span class="mi">2738676825</span> <span class="mi">1694441831</span> <span class="mi">4142722516</span> <span class="mi">433784513</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">refsha256</span> <span class="n">msg3</span>
  <span class="kt">Oct</span> <span class="mi">3452399196</span> <span class="mi">2568289170</span> <span class="mi">2174863330</span> <span class="mi">2228698727</span> 
      <span class="mi">4051737160</span> <span class="mi">2761367566</span> <span class="mi">74267084</span> <span class="mi">3339791568</span>
<span class="n">ghci</span><span class="o">&gt;</span> <span class="n">hashed3</span>
  <span class="kt">Oct</span> <span class="mi">3452399196</span> <span class="mi">2568289170</span> <span class="mi">2174863330</span> <span class="mi">2228698727</span> 
      <span class="mi">4051737160</span> <span class="mi">2761367566</span> <span class="mi">74267084</span> <span class="mi">3339791568</span> 
</code></pre>
</div>

<p>In the above transcript, a test harness is loaded into the GHC (Glasgow Haskell Compiler) interpreter. First the <code class="highlighter-rouge">refsha256</code> is applied, producing the hash digest calculated by the reference semantics. Then, the published hash digests from <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">NIST</a>, Appendix B, are displayed—these are <code class="highlighter-rouge">hashed1</code>, <code class="highlighter-rouge">hashed2</code>, and <code class="highlighter-rouge">hashed3</code>, respectively—and note that they are identical to the corresponding output of <code class="highlighter-rouge">refsha256</code>. By default, these digests are displayed in decimal format rather than the hexadecimal format in which they appear in <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">NIST</a>.</p>

<h4 id="sha-256-logical-operators"><strong>SHA-256 Logical Operators</strong></h4>

<p>SHA-256 defines a number of operations on 32-bit words called <em>logical operators</em> in Sections 3.2 and 4.1.2 of <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">NIST</a>. These are excerpted in part below:</p>

<p><img src="/images/sha256-functions.png" style="display: block; margin: 0 auto; max-width: 75%;" alt="Screenshot" /></p>

<p>Each of these functions transliterates simply into Haskell using built-in functions and data from the Haskell libraries, <code class="highlighter-rouge">Data.Bit</code> and <code class="highlighter-rouge">Data.Word</code>.
Within the code listing below, <code class="highlighter-rouge">.&amp;.</code>, <code class="highlighter-rouge">complement</code>, and <code class="highlighter-rouge">xor</code> are, resp., the bitwise <em>and</em>, complement and exclusive <em>or</em> operations. The <code class="highlighter-rouge">rotateR</code> and <code class="highlighter-rouge">shiftR</code> functions are the rotate right and shift right operations.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">ch</span> <span class="o">::</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">Word32</span>
<span class="n">ch</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">.&amp;.</span> <span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">xor</span><span class="p">`</span> <span class="p">(</span><span class="n">complement</span> <span class="n">x</span> <span class="o">.&amp;.</span> <span class="n">z</span><span class="p">)</span>

<span class="n">maj</span> <span class="o">::</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">Word32</span>
<span class="n">maj</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">.&amp;.</span> <span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">xor</span><span class="p">`</span> <span class="p">(</span><span class="n">x</span> <span class="o">.&amp;.</span> <span class="n">z</span><span class="p">)</span> <span class="p">`</span><span class="n">xor</span><span class="p">`</span> <span class="p">(</span><span class="n">y</span> <span class="o">.&amp;.</span> <span class="n">z</span><span class="p">)</span>

<span class="n">bigsigma0</span> <span class="o">::</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">Word32</span>
<span class="n">bigsigma0</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotateR</span> <span class="n">x</span> <span class="mi">2</span><span class="p">)</span> <span class="p">`</span><span class="n">xor</span><span class="p">`</span> <span class="p">(</span><span class="n">rotateR</span> <span class="n">x</span> <span class="mi">13</span><span class="p">)</span> <span class="p">`</span><span class="n">xor</span><span class="p">`</span> <span class="p">(</span><span class="n">rotateR</span> <span class="n">x</span> <span class="mi">22</span><span class="p">)</span>

<span class="n">bigsigma1</span> <span class="o">::</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">Word32</span>
<span class="n">bigsigma1</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotateR</span> <span class="n">x</span> <span class="mi">6</span><span class="p">)</span> <span class="p">`</span><span class="n">xor</span><span class="p">`</span> <span class="p">(</span><span class="n">rotateR</span> <span class="n">x</span> <span class="mi">11</span><span class="p">)</span> <span class="p">`</span><span class="n">xor</span><span class="p">`</span> <span class="p">(</span><span class="n">rotateR</span> <span class="n">x</span> <span class="mi">25</span><span class="p">)</span>

<span class="n">sigma0</span> <span class="o">::</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">Word32</span>
<span class="n">sigma0</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotateR</span> <span class="n">x</span> <span class="mi">7</span><span class="p">)</span> <span class="p">`</span><span class="n">xor</span><span class="p">`</span> <span class="p">(</span><span class="n">rotateR</span> <span class="n">x</span> <span class="mi">18</span><span class="p">)</span> <span class="p">`</span><span class="n">xor</span><span class="p">`</span> <span class="p">(</span><span class="n">shiftR</span> <span class="n">x</span> <span class="mi">3</span><span class="p">)</span>

<span class="n">sigma1</span> <span class="o">::</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">Word32</span>
<span class="n">sigma1</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotateR</span> <span class="n">x</span> <span class="mi">17</span><span class="p">)</span> <span class="p">`</span><span class="n">xor</span><span class="p">`</span> <span class="p">(</span><span class="n">rotateR</span> <span class="n">x</span> <span class="mi">19</span><span class="p">)</span> <span class="p">`</span><span class="n">xor</span><span class="p">`</span> <span class="p">(</span><span class="n">shiftR</span> <span class="n">x</span> <span class="mi">10</span><span class="p">)</span>
</code></pre>
</div>

<h4 id="constants-and-counters"><strong>Constants and Counters</strong></h4>

<p>The inner loop of the SHA-256 algorithm is, in effect, a for-loop counting from $0$ to $63$. To allow expression of this in Haskell, we define a counter type <code class="highlighter-rouge">Ctr</code> below.
It would be possible in the reference semantics to use the built-in <code class="highlighter-rouge">Int</code> type as a loop variable, but, anticipating the shift to hardware implementation, a discrete, finite type like <code class="highlighter-rouge">Ctr</code> makes more sense.
The SHA-256 algorithm also makes use of 64 constants (these are defined in Section 4.2.2 of <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">NIST</a>). We index these constants via the <code class="highlighter-rouge">seed</code> function. This code appears in <code class="highlighter-rouge">Counter.hs</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Ctr</span> <span class="o">=</span> <span class="kt">C0</span>  <span class="o">|</span> <span class="kt">C1</span>  <span class="o">|</span> <span class="kt">C2</span>  <span class="o">|</span> <span class="kt">C3</span>  <span class="o">|</span> <span class="kt">C4</span>  <span class="o">|</span> <span class="kt">C5</span>  <span class="o">|</span> <span class="kt">C6</span>  <span class="o">|</span> <span class="kt">C7</span>  <span class="o">|</span>
           <span class="kt">C8</span>  <span class="o">|</span> <span class="kt">C9</span>  <span class="o">|</span> <span class="kt">C10</span> <span class="o">|</span> <span class="kt">C11</span> <span class="o">|</span> <span class="kt">C12</span> <span class="o">|</span> <span class="kt">C13</span> <span class="o">|</span> <span class="kt">C14</span> <span class="o">|</span> <span class="kt">C15</span> <span class="o">|</span>
           <span class="kt">C16</span> <span class="o">|</span> <span class="kt">C17</span> <span class="o">|</span> <span class="kt">C18</span> <span class="o">|</span> <span class="kt">C19</span> <span class="o">|</span> <span class="kt">C20</span> <span class="o">|</span> <span class="kt">C21</span> <span class="o">|</span> <span class="kt">C22</span> <span class="o">|</span> <span class="kt">C23</span> <span class="o">|</span>
           <span class="kt">C24</span> <span class="o">|</span> <span class="kt">C25</span> <span class="o">|</span> <span class="kt">C26</span> <span class="o">|</span> <span class="kt">C27</span> <span class="o">|</span> <span class="kt">C28</span> <span class="o">|</span> <span class="kt">C29</span> <span class="o">|</span> <span class="kt">C30</span> <span class="o">|</span> <span class="kt">C31</span> <span class="o">|</span>
           <span class="kt">C32</span> <span class="o">|</span> <span class="kt">C33</span> <span class="o">|</span> <span class="kt">C34</span> <span class="o">|</span> <span class="kt">C35</span> <span class="o">|</span> <span class="kt">C36</span> <span class="o">|</span> <span class="kt">C37</span> <span class="o">|</span> <span class="kt">C38</span> <span class="o">|</span> <span class="kt">C39</span> <span class="o">|</span>
           <span class="kt">C40</span> <span class="o">|</span> <span class="kt">C41</span> <span class="o">|</span> <span class="kt">C42</span> <span class="o">|</span> <span class="kt">C43</span> <span class="o">|</span> <span class="kt">C44</span> <span class="o">|</span> <span class="kt">C45</span> <span class="o">|</span> <span class="kt">C46</span> <span class="o">|</span> <span class="kt">C47</span> <span class="o">|</span>
           <span class="kt">C48</span> <span class="o">|</span> <span class="kt">C49</span> <span class="o">|</span> <span class="kt">C50</span> <span class="o">|</span> <span class="kt">C51</span> <span class="o">|</span> <span class="kt">C52</span> <span class="o">|</span> <span class="kt">C53</span> <span class="o">|</span> <span class="kt">C54</span> <span class="o">|</span> <span class="kt">C55</span> <span class="o">|</span>
           <span class="kt">C56</span> <span class="o">|</span> <span class="kt">C57</span> <span class="o">|</span> <span class="kt">C58</span> <span class="o">|</span> <span class="kt">C59</span> <span class="o">|</span> <span class="kt">C60</span> <span class="o">|</span> <span class="kt">C61</span> <span class="o">|</span> <span class="kt">C62</span> <span class="o">|</span> <span class="kt">C63</span> 

<span class="n">incCtr</span> <span class="o">::</span> <span class="kt">Ctr</span> <span class="o">-&gt;</span> <span class="kt">Ctr</span>
<span class="n">incCtr</span> <span class="kt">C0</span>  <span class="o">=</span> <span class="kt">C1</span>
    <span class="o">...</span><span class="n">stuff</span> <span class="n">deleted</span><span class="o">...</span>
<span class="n">incCtr</span> <span class="kt">C62</span> <span class="o">=</span> <span class="kt">C63</span>
<span class="n">incCtr</span> <span class="kt">C63</span> <span class="o">=</span> <span class="kt">C0</span> 

<span class="n">seed</span> <span class="o">::</span> <span class="kt">Ctr</span> <span class="o">-&gt;</span> <span class="kt">Word32</span>
<span class="n">seed</span> <span class="kt">C0</span>  <span class="o">=</span> <span class="mh">0x428a2f98</span>
    <span class="o">...</span><span class="n">stuff</span> <span class="n">deleted</span><span class="o">...</span>
<span class="n">seed</span> <span class="kt">C63</span> <span class="o">=</span> <span class="mh">0xc67178f2</span>
</code></pre>
</div>

<h4 id="memory-layout-of-sha-256">Memory Layout of SHA-256</h4>

<p>SHA-256 is an imperative algorithm, meaning that it involves assignments to registers, loops, etc. 
To program in imperative style in Haskell, one normally uses state monads. This section will provide a quick refresher of the fundamentals of monadic programming in Haskell for the sake of being as self-contained as possible. For readers requiring more information, please consult, for example,  <a href="http://dl.acm.org/citation.cfm?id=199528">Liang 1995</a>.</p>

<p>There are four types of storage in the algorithm:</p>

<ul>
  <li>Intermediate Digest: temporary storage for a digest value; of type <code class="highlighter-rouge">Oct Word32</code>.</li>
  <li>Current Block: the current, formatted block; of type <code class="highlighter-rouge">Hex Word32</code>.</li>
  <li>Digest: the value of the digest; of type <code class="highlighter-rouge">Oct Word32</code>.</li>
  <li>Loop Counter: the current value of the loop counter register of type <code class="highlighter-rouge">Ctr</code>.</li>
</ul>

<p>To create storable registers for each of these types, we create a monad <code class="highlighter-rouge">M</code> using the state monad transformer <code class="highlighter-rouge">StateT</code> in the code below. Notice that, for each type of register above, there is a corresponding application of the state monad transformer. This stack of <code class="highlighter-rouge">StateT</code> applications applies to the <code class="highlighter-rouge">Identity</code> monad, which has no registers at all.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">type</span> <span class="kt">M</span> <span class="o">=</span> 
  <span class="kt">StateT</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">Word32</span><span class="p">)</span>                <span class="c1">-- Intermediate Digest</span>
    <span class="p">(</span><span class="kt">StateT</span> <span class="p">(</span><span class="kt">Hex</span> <span class="kt">Word32</span><span class="p">)</span>             <span class="c1">-- Current Block</span>
       <span class="p">(</span><span class="kt">StateT</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">Word32</span><span class="p">)</span>          <span class="c1">-- Digest</span>
          <span class="p">(</span><span class="kt">StateT</span> <span class="kt">Ctr</span> <span class="kt">Identity</span><span class="p">)))</span>    <span class="c1">-- Loop Counter</span>
</code></pre>
</div>

<p>For each register type, there are corresponding read and write operations in <code class="highlighter-rouge">M</code> for manipulating the register. These operations are prepended with <code class="highlighter-rouge">get</code> and <code class="highlighter-rouge">put</code>, respectively, and are defined below.
Paying attention to the types of the operation is the best way to understand them. For example,
to read the current digest value, one uses <code class="highlighter-rouge">getDigest :: M (Oct Word32)</code>.
This type signifies that <code class="highlighter-rouge">getDigest</code> is an <code class="highlighter-rouge">M</code> computation that returns an <code class="highlighter-rouge">Oct Word32</code> value.
To update the current value of the digest register, one uses <code class="highlighter-rouge">putDigest :: Oct Word32 -&gt; M()</code>.
For a given 
<code class="highlighter-rouge">d :: Oct Word32</code>, <code class="highlighter-rouge">(putDigest d) :: M()</code> is a computation that sets the current value of the digest register to <code class="highlighter-rouge">d</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">getIntDig</span> <span class="o">::</span> <span class="kt">M</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">Word32</span><span class="p">)</span>         <span class="c1">-- Intermediate Digest Operations</span>
<span class="n">getIntDig</span> <span class="o">=</span> <span class="n">get</span>
<span class="n">putIntDig</span> <span class="o">::</span> <span class="kt">Oct</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">M</span> <span class="nb">()</span>
<span class="n">putIntDig</span> <span class="o">=</span> <span class="n">put</span>

<span class="n">getBlock</span> <span class="o">::</span> <span class="kt">M</span> <span class="p">(</span><span class="kt">Hex</span> <span class="kt">Word32</span><span class="p">)</span>          <span class="c1">-- Current Block Operations</span>
<span class="n">getBlock</span> <span class="o">=</span> <span class="n">lift</span> <span class="n">get</span>
<span class="n">putBlock</span> <span class="o">::</span> <span class="kt">Hex</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">M</span> <span class="nb">()</span>
<span class="n">putBlock</span> <span class="o">=</span> <span class="n">lift</span> <span class="o">.</span> <span class="n">put</span>

<span class="n">getDigest</span> <span class="o">::</span> <span class="kt">M</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">Word32</span><span class="p">)</span>         <span class="c1">-- Digest Operations</span>
<span class="n">getDigest</span> <span class="o">=</span> <span class="n">lift</span> <span class="p">(</span><span class="n">lift</span> <span class="n">get</span><span class="p">)</span>
<span class="n">putDigest</span> <span class="o">::</span> <span class="kt">Oct</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">M</span> <span class="nb">()</span>
<span class="n">putDigest</span> <span class="o">=</span> <span class="n">lift</span> <span class="o">.</span> <span class="n">lift</span> <span class="o">.</span> <span class="n">put</span>

<span class="n">getCtr</span> <span class="o">::</span> <span class="kt">M</span> <span class="kt">Ctr</span>                     <span class="c1">-- Loop Counter Operations</span>
<span class="n">getCtr</span> <span class="o">=</span> <span class="n">lift</span> <span class="p">(</span><span class="n">lift</span> <span class="p">(</span><span class="n">lift</span> <span class="n">get</span><span class="p">))</span>
<span class="n">putCtr</span> <span class="o">::</span> <span class="kt">Ctr</span> <span class="o">-&gt;</span> <span class="kt">M</span> <span class="nb">()</span>
<span class="n">putCtr</span> <span class="o">=</span> <span class="n">lift</span> <span class="o">.</span> <span class="n">lift</span> <span class="o">.</span> <span class="n">lift</span> <span class="o">.</span> <span class="n">put</span>
</code></pre>
</div>

<p>To chain together these operations, we use Haskell’s <code class="highlighter-rouge">do</code> notation. In the code below, first the current digest is read with <code class="highlighter-rouge">getDigest</code>, then the current intermediate digest is read with <code class="highlighter-rouge">getIntDig</code>, and finally they are added together component-wise and stored back in the digest register using <code class="highlighter-rouge">putDigest</code>. This <code class="highlighter-rouge">intermediate</code> operation is part of the Haskell reference semantics for SHA-256.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">intermediate</span> <span class="o">::</span> <span class="kt">M</span> <span class="nb">()</span>
<span class="n">intermediate</span> <span class="o">=</span> 
   <span class="kr">do</span>
      <span class="kt">Oct</span> <span class="n">h1</span> <span class="n">h2</span> <span class="n">h3</span> <span class="n">h4</span> <span class="n">h5</span> <span class="n">h6</span> <span class="n">h7</span> <span class="n">h8</span> <span class="o">&lt;-</span> <span class="n">getDigest</span>
      <span class="kt">Oct</span> <span class="n">a</span> <span class="n">b</span> <span class="n">c</span> <span class="n">d</span> <span class="n">e</span> <span class="n">f</span> <span class="n">g</span> <span class="n">h</span>         <span class="o">&lt;-</span> <span class="n">getIntDig</span>
      <span class="n">putDigest</span> <span class="p">(</span><span class="kt">Oct</span> <span class="p">(</span><span class="n">a</span><span class="o">+</span><span class="n">h1</span><span class="p">)</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="n">h2</span><span class="p">)</span> <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">h3</span><span class="p">)</span> <span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="n">h4</span><span class="p">)</span> 
                     <span class="p">(</span><span class="n">e</span><span class="o">+</span><span class="n">h5</span><span class="p">)</span> <span class="p">(</span><span class="n">f</span><span class="o">+</span><span class="n">h6</span><span class="p">)</span> <span class="p">(</span><span class="n">g</span><span class="o">+</span><span class="n">h7</span><span class="p">)</span> <span class="p">(</span><span class="n">h</span><span class="o">+</span><span class="n">h8</span><span class="p">))</span>
</code></pre>
</div>

<p>There is one more <code class="highlighter-rouge">M</code> operation to describe: <code class="highlighter-rouge">return :: a -&gt; M a</code>. This polymorphic operation takes a value <code class="highlighter-rouge">v</code> of some type <code class="highlighter-rouge">a</code> and produces an <code class="highlighter-rouge">M</code> computation that simply returns <code class="highlighter-rouge">v</code>. The <code class="highlighter-rouge">return</code> operation produces no side effects and is, in some sense, a "do nothing" operation.</p>

<h4 id="main-function"><strong>Main Function</strong></h4>

<p>Below is displayed the Haskell code for the main loop of the SHA-256 algorithm, which is represented by the recursive list function <code class="highlighter-rouge">sha256</code>.
The <code class="highlighter-rouge">sha256</code> function first initializes the digest and then passes the parsed input on to the <code class="highlighter-rouge">mainloop</code> function. The <code class="highlighter-rouge">mainloop</code> function is a straightforward rendering of the pseudo-code defining the main
loop of SHA-256 (see Section 6.2.2 of <a href="http://csrc.nist.gov/publications/fips/fips180-2/fips180-2.pdf">NIST</a>).
The code for the message scheduling and compression routines can be found in <code class="highlighter-rouge">Reference256.hs</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">sha256</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Hex</span> <span class="kt">Word32</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">M</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">Word32</span><span class="p">)</span>
<span class="n">sha256</span> <span class="n">hws</span> <span class="o">=</span> <span class="kr">do</span>
                <span class="n">putDigest</span> <span class="n">initialSHA256State</span>
                <span class="n">mainloop</span> <span class="n">hws</span>
                <span class="n">getDigest</span>

<span class="n">mainloop</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Hex</span> <span class="kt">Word32</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">M</span> <span class="nb">()</span>
<span class="n">mainloop</span> <span class="kt">[]</span>             <span class="o">=</span> <span class="n">return</span> <span class="nb">()</span>
<span class="n">mainloop</span> <span class="p">(</span><span class="n">hw32</span> <span class="o">:</span> <span class="n">hw32s</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
                             <span class="n">hi_1</span> <span class="o">&lt;-</span> <span class="n">getDigest</span>
                             <span class="n">putIntDig</span> <span class="n">hi_1</span>
                             <span class="n">putBlock</span> <span class="n">hw32</span>
                             <span class="n">putCtr</span> <span class="kt">C0</span>
                             <span class="n">innerloop</span>
                             <span class="n">mainloop</span> <span class="n">hw32s</span>

<span class="n">innerloop</span> <span class="o">::</span> <span class="kt">M</span> <span class="nb">()</span>
<span class="n">innerloop</span> <span class="o">=</span> <span class="kr">do</span>
               <span class="n">ctr</span> <span class="o">&lt;-</span> <span class="n">getCtr</span>
               <span class="n">s</span> <span class="o">&lt;-</span> <span class="n">sched</span>
               <span class="n">compress</span> <span class="p">(</span><span class="n">seed</span> <span class="n">ctr</span><span class="p">)</span> <span class="n">s</span>
               <span class="n">putCtr</span> <span class="p">(</span><span class="n">incCtr</span> <span class="n">ctr</span><span class="p">)</span>
               <span class="kr">case</span> <span class="n">ctr</span> <span class="kr">of</span>
                    <span class="kt">C63</span> <span class="o">-&gt;</span> <span class="n">intermediate</span>
                    <span class="kr">_</span>   <span class="o">-&gt;</span> <span class="n">innerloop</span>

<span class="c1">-- SHA-256 message scheduling and compression routines</span>
<span class="n">sched</span>    <span class="o">::</span> <span class="kt">M</span> <span class="kt">Word32</span>
<span class="n">compress</span> <span class="o">::</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">Word32</span> <span class="o">-&gt;</span> <span class="kt">M</span> <span class="nb">()</span>
</code></pre>
</div>

<h3 id="iii-the-first-implementation">III. The First Implementation</h3>

<p>The reference semantics as a whole will not translate directly to hardware: it makes extensive use of list types in Haskell (i.e., list types) that are of potentially unbounded size. Hardware circuits, which require a finite storage footprint, cannot accommodate such types generally. However, large parts of the reference semantics may be re-used in a ReWire specification of a circuit that computes the <code class="highlighter-rouge">sha256</code> function from the end of the previous section, albeit with a different calling convention to eliminate lists.</p>

<h4 id="hardware-accelerator-for-sha-256-in-haskell"><strong>Hardware Accelerator for SHA-256 in Haskell</strong></h4>

<p>The code below presents the input and output signals for the hardware accelerator device; these are the <code class="highlighter-rouge">Inp</code> and <code class="highlighter-rouge">Out</code> types, resp. 
The <code class="highlighter-rouge">Init</code> input signal tells the accelerator to initialize the current block and begin a new hash computation. The <code class="highlighter-rouge">Load</code> signal instructs the accelerator to load new input into the current block register. The <code class="highlighter-rouge">DigestQ</code> signal is used to return the computed hash digest.
The <code class="highlighter-rouge">DigestR</code> output signal returns the computed hash digest and the <code class="highlighter-rouge">Nix</code> output signal is the default output of the accelerator.
The code below also presents the definition of the SHA-256 accelerator. 
The most important thing to note is that <code class="highlighter-rouge">devsha256</code> reuses most of the code directly from the reference semantics <code class="highlighter-rouge">sha256</code>.
First, <code class="highlighter-rouge">devsha256</code> outputs the <code class="highlighter-rouge">Nix</code> signal, receives an input <code class="highlighter-rouge">i</code> and passes it to <code class="highlighter-rouge">dev</code>. The function <code class="highlighter-rouge">dev</code> handles each <code class="highlighter-rouge">Inp</code> signal as described in the previous paragraph.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Inp</span> <span class="o">=</span> <span class="kt">Init</span> <span class="p">(</span><span class="kt">Hex</span> <span class="kt">Word32</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Load</span> <span class="p">(</span><span class="kt">Hex</span> <span class="kt">Word32</span><span class="p">)</span> <span class="o">|</span> <span class="kt">DigestQ</span>
<span class="kr">data</span> <span class="kt">Out</span> <span class="o">=</span> <span class="kt">DigestR</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">Word32</span><span class="p">)</span> <span class="o">|</span> <span class="kt">Nix</span>

<span class="kr">type</span> <span class="kt">Device</span> <span class="o">=</span> <span class="kt">ReacT</span> <span class="kt">Inp</span> <span class="kt">Out</span> <span class="kt">M</span> <span class="nb">()</span>

<span class="n">devsha256</span> <span class="o">::</span> <span class="kt">Device</span>
<span class="n">devsha256</span> <span class="o">=</span> <span class="kr">do</span> 
               <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">signal</span> <span class="kt">Nix</span>
               <span class="n">dev</span> <span class="n">i</span>

<span class="n">dev</span> <span class="o">::</span> <span class="kt">Inp</span> <span class="o">-&gt;</span> <span class="kt">Device</span>
<span class="n">dev</span> <span class="p">(</span><span class="kt">Init</span> <span class="n">hw32</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
                     <span class="n">lift</span> <span class="p">(</span><span class="kr">do</span>
                              <span class="n">putDigest</span> <span class="n">initialSHA256State</span>
                              <span class="n">hi_1</span> <span class="o">&lt;-</span> <span class="n">getDigest</span>
                              <span class="n">putIntDig</span> <span class="n">hi_1</span>
                              <span class="n">putBlock</span> <span class="n">hw32</span>
                              <span class="n">putCtr</span> <span class="kt">C0</span><span class="p">)</span>
                     <span class="n">signal</span> <span class="kt">Nix</span>
                     <span class="n">innerloop</span> 
<span class="n">dev</span> <span class="p">(</span><span class="kt">Load</span> <span class="n">hw32</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
                     <span class="n">lift</span> <span class="p">(</span><span class="kr">do</span>
                              <span class="n">hi_1</span> <span class="o">&lt;-</span> <span class="n">getDigest</span>
                              <span class="n">putIntDig</span> <span class="n">hi_1</span>
                              <span class="n">putBlock</span> <span class="n">hw32</span>
                              <span class="n">putCtr</span> <span class="kt">C0</span><span class="p">)</span>
                     <span class="n">signal</span> <span class="kt">Nix</span>
                     <span class="n">innerloop</span>
<span class="n">dev</span> <span class="kt">DigestQ</span>     <span class="o">=</span> <span class="kr">do</span>
                     <span class="n">h_n</span> <span class="o">&lt;-</span> <span class="n">lift</span> <span class="n">getDigest</span> 
                     <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">signal</span> <span class="p">(</span><span class="kt">DigestR</span> <span class="n">h_n</span><span class="p">)</span>
                     <span class="n">dev</span> <span class="n">i</span>

<span class="n">innerloop</span> <span class="o">::</span> <span class="kt">Device</span>
<span class="n">innerloop</span>   <span class="o">=</span> <span class="kr">do</span>
                 <span class="n">ctr</span> <span class="o">&lt;-</span> <span class="n">lift</span> <span class="p">(</span><span class="kr">do</span>
                                 <span class="n">c</span> <span class="o">&lt;-</span> <span class="n">getCtr</span>
                                 <span class="n">s</span> <span class="o">&lt;-</span> <span class="n">sched</span>
                                 <span class="n">compress</span> <span class="p">(</span><span class="n">seed</span> <span class="n">c</span><span class="p">)</span> <span class="n">s</span>
                                 <span class="n">putCtr</span> <span class="p">(</span><span class="n">incCtr</span> <span class="n">c</span><span class="p">)</span>
                                 <span class="n">return</span> <span class="n">c</span><span class="p">)</span>
                 <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">signal</span> <span class="kt">Nix</span>
                 <span class="kr">case</span> <span class="n">ctr</span> <span class="kr">of</span>
                      <span class="kt">C63</span> <span class="o">-&gt;</span> <span class="kr">do</span> <span class="n">lift</span> <span class="n">intermediate</span> 
                                <span class="n">dev</span> <span class="n">i</span>
                      <span class="kr">_</span>   <span class="o">-&gt;</span> <span class="n">innerloop</span>
</code></pre>
</div>

<h4 id="top-level-for-devsha256"><strong>Top Level for <code class="highlighter-rouge">devsha256</code></strong></h4>

<p>The code below presents the top-level functions for testing the <code class="highlighter-rouge">devsha256</code> accelerator in Haskell. Below, we discuss the calling convention for <code class="highlighter-rouge">devsha256</code>, which is encapsulated as the <code class="highlighter-rouge">format</code> function. The <code class="highlighter-rouge">simdev</code> function takes a <code class="highlighter-rouge">Device</code> and a list of <code class="highlighter-rouge">Inp</code>s and computes the final <code class="highlighter-rouge">Out</code> signal produced by the device on those inputs. The code for both of the functions is found in <code class="highlighter-rouge">TestHarness.hs</code>.
Importantly, the hardware accelerator may be tested in Haskell: using <code class="highlighter-rouge">godev256</code> produces the same results as the <code class="highlighter-rouge">refsha256</code> did in Section II.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">godev256</span> <span class="o">::</span> <span class="p">[</span><span class="kt">Char</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Out</span>
<span class="n">godev256</span> <span class="o">=</span> <span class="n">runM</span> <span class="o">.</span> <span class="n">simdev</span> <span class="n">devsha256</span> <span class="o">.</span> <span class="n">format</span> <span class="o">.</span> <span class="n">pad</span>
<span class="n">format</span>    <span class="o">::</span> <span class="p">[</span><span class="kt">Hex</span> <span class="kt">Word32</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Inp</span><span class="p">]</span>
<span class="n">simdev</span>    <span class="o">::</span> <span class="kt">Device</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">Inp</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">M</span> <span class="kt">Out</span>
</code></pre>
</div>

<p>To call the main function from the reference semantics, one simply applies the function <code class="highlighter-rouge">sha256</code> to the list of input blocks. 
That is, ${\mathtt{sha256~ [{\mathit{M}}^{(\mathit{1})},\ldots,{\mathit{M}}^{(\mathit{N})}]}}$ computes a digest. 
The device version, <code class="highlighter-rouge">devsha256</code>, requires that this input be formatted differently, and this is accomplished with the function, <code class="highlighter-rouge">format :: [Hex Word32] -&gt; [Inp]</code>. 
The code for <code class="highlighter-rouge">format</code> is defined in <code class="highlighter-rouge">TestHarness.hs</code>, but the 
action of the <code class="highlighter-rouge">format</code> function is described below:</p>

<script type="math/tex; mode=display">\mathtt{format} [M^{(1)},\ldots,M^{(N)}] =
\begin{array}[t]{l}
[\mathtt{Init}~ M^{(1)}, \underbrace{\mathtt{DigestQ},\ldots,\mathtt{DigestQ}}_{\times{64}},
\\
~\mathtt{Load}~ M^{(2)}, \underbrace{\mathtt{DigestQ},\ldots,\mathtt{DigestQ}}_{\times{64}},
\\
~~~~~~~~~~~~~~~~~~~~~~~~\vdots
\\
~\mathtt{Load}~ M^{(N)}, \underbrace{\mathtt{DigestQ},\ldots,\mathtt{DigestQ}}_{\times{64}},
\\
~\mathtt{DigestQ}]
\end{array}</script>

<p>This calling convention is analogous to those found in publications presenting SHA-256 accelerators hand-coded in VHDL (e.g., 
<a href="http://link.springer.com/chapter/10.1007%2F11894063_24">Chaves06</a>,
<a href="http://www.sciencedirect.com/science/article/pii/S0141933112000993">Algredo13</a>, 
<a href="http://link.springer.com/chapter/10.1007%2F3-540-46117-5_60">Ting02</a>, 
<a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=1602458&amp;tag=1">McEvoy06</a>, 
<a href="http://www.sciencedirect.com/science/article/pii/S0045790613002966">Garcia14</a>, 
<a href="http://link.springer.com/article/10.1007%2Fs11227-005-0086-5">Sklavos05</a>, and
<a href="http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=7348105">Kahri15</a>).
Note that the sixty four <code class="highlighter-rouge">DigestQ</code> signals are used only as padding to wait for the inner loop within the device to finish. The final <code class="highlighter-rouge">DigestQ</code> will result in the completed hash value being returned.</p>

<h3 id="hardware-accelerator-for-sha-256-in-rewire">Hardware Accelerator for SHA-256 in ReWire</h3>

<p>This section highlights the transformations required of the first implementation (i.e., <code class="highlighter-rouge">FirstImplementation.hs</code>) to produce a ReWire implementation (i.e., <code class="highlighter-rouge">RWFirstImplementation.hs</code>).
These changes proceed along the following lines:</p>

<ul>
  <li>Recasting the Primitive Types and Operations. We have, heretofore, used the <code class="highlighter-rouge">Word32</code> type and related operations from the Haskell libraries <code class="highlighter-rouge">Data.Bit</code> and <code class="highlighter-rouge">Data.Word</code>. To produce a synthesizable implementation, we implement our own type, <code class="highlighter-rouge">W32</code>, and related operations. In this part, we see how to link a ReWire type to an implementation in VHDL using the ReWire keyword <code class="highlighter-rouge">nativeVhdl</code>.</li>
  <li>Eliminating <code class="highlighter-rouge">type</code> synonyms. This mainly involves eliminating the use of <code class="highlighter-rouge">M</code>.</li>
  <li>Adding a <code class="highlighter-rouge">start</code> symbol. This will involve the <code class="highlighter-rouge">extrude</code> primitive used whenever devices have internal state (i.e., use the state monad transformer).</li>
</ul>

<h4 id="recasting-the-primitive-types-and-operations"><strong>Recasting the Primitive Types and Operations</strong></h4>

<p>Up to this point, we have used the <code class="highlighter-rouge">Word32</code> type provided by the Haskell libraries, <code class="highlighter-rouge">Data.Bit</code> and <code class="highlighter-rouge">Data.Word</code>. This has been very convenient for the rapid prototyping of the SHA-256 algorithm in Haskell, because those libraries have nice syntax for 32-bit words (e.g., <code class="highlighter-rouge">0x0</code>) and common operations (e.g., <code class="highlighter-rouge">+</code> and <code class="highlighter-rouge">.&amp;.</code>) are already defined. In this section, we describe the conversion of the specification from <code class="highlighter-rouge">Word32</code>  to the <code class="highlighter-rouge">W32</code> type provided in the ReWire prelude (i.e., <code class="highlighter-rouge">ReWirePrelude.hs</code>). This conversion is necessary to transform the SHA-256 specification into proper ReWire.</p>

<h5 id="constants"><strong>Constants</strong></h5>

<p>With the Haskell libraries <code class="highlighter-rouge">Data.Bit</code> and <code class="highlighter-rouge">Data.Word</code>, one can write hexadecimal constants for 32 bit words by prepending the constant with <code class="highlighter-rouge">0x</code>, as in the following code we have already seen:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">seed</span> <span class="o">::</span> <span class="kt">Ctr</span> <span class="o">-&gt;</span> <span class="kt">Word32</span>
<span class="n">seed</span> <span class="kt">C0</span>  <span class="o">=</span> <span class="mh">0x428a2f98</span>
<span class="n">seed</span> <span class="kt">C1</span>  <span class="o">=</span> <span class="mh">0x71374491</span>
<span class="n">seed</span> <span class="kt">C2</span>  <span class="o">=</span> <span class="mh">0xb5c0fbcf</span>
     <span class="o">...</span>
</code></pre>
</div>

<p>This syntax for constants is not available from the ReWire front end, and so each constant required by the SHA-256 algorithm must be defined as a value of type <code class="highlighter-rouge">W32</code>, as in the following code (from <code class="highlighter-rouge">MetaprogrammingRW.hs</code>).</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">w428a2f98</span> <span class="o">::</span> <span class="kt">W32</span>
<span class="n">w428a2f98</span> <span class="o">=</span> <span class="kt">W32</span> <span class="kt">Zero</span> <span class="kt">One</span> <span class="kt">Zero</span> <span class="kt">Zero</span> <span class="kt">Zero</span> <span class="kt">Zero</span> <span class="kt">One</span> <span class="kt">Zero</span> <span class="kt">One</span> <span class="kt">Zero</span> <span class="kt">Zero</span> <span class="kt">Zero</span> <span class="kt">One</span> <span class="kt">Zero</span> <span class="kt">One</span> <span class="kt">Zero</span> <span class="kt">Zero</span> <span class="kt">Zero</span> <span class="kt">One</span> <span class="kt">Zero</span> <span class="kt">One</span> <span class="kt">One</span> <span class="kt">One</span> <span class="kt">One</span> <span class="kt">One</span> <span class="kt">Zero</span> <span class="kt">Zero</span> <span class="kt">One</span> <span class="kt">One</span> <span class="kt">Zero</span> <span class="kt">Zero</span> <span class="kt">Zero</span>
</code></pre>
</div>

<p>While this is a bit tedious to perform these instantiations, the burden was alleviated somewhat by Haskell code to generate them — see the commented code in <code class="highlighter-rouge">MetaprogrammingRW.hs</code>. Once all the necessary constants have been defined, the <code class="highlighter-rouge">Word32</code> constants were replaced with their corresponding <code class="highlighter-rouge">W32</code> constants; please note the change of type declarations as well.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">seed</span> <span class="o">::</span> <span class="kt">Ctr</span> <span class="o">-&gt;</span> <span class="kt">W32</span>
<span class="n">seed</span> <span class="kt">C0</span>  <span class="o">=</span> <span class="n">w428a2f98</span>
<span class="n">seed</span> <span class="kt">C1</span>  <span class="o">=</span> <span class="n">w71374491</span>
<span class="n">seed</span> <span class="kt">C2</span>  <span class="o">=</span> <span class="n">wb5c0fbcf</span>
     <span class="o">...</span>
</code></pre>
</div>

<h5 id="native-vhdl-implementations-of-w32-operations"><strong>Native VHDL Implementations of <code class="highlighter-rouge">W32</code> operations</strong></h5>

<p>The <code class="highlighter-rouge">Data.Bit</code> and <code class="highlighter-rouge">Data.Word</code> Haskell libraries also provided implementations for standard operations: addition (<code class="highlighter-rouge">+</code>), bitwise and (<code class="highlighter-rouge">.&amp;.</code>), bitwise exclusive or (<code class="highlighter-rouge">xor</code>), and bitwise complement (<code class="highlighter-rouge">complement</code>) as well as rotate and shift operations.
These we replace, respectively, by <code class="highlighter-rouge">w32Plus</code>, <code class="highlighter-rouge">w32And</code>, <code class="highlighter-rouge">w32Xor</code>, and <code class="highlighter-rouge">w32Not</code>. The rotate and shift operations are replaced by operations from <code class="highlighter-rouge">ReWirePrelude.hs</code>. So, for example, the code for the SHA-256 logical operators now becomes the following:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">ch</span> <span class="o">::</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span>
<span class="n">ch</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">w32And</span><span class="p">`</span> <span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">w32Xor</span><span class="p">`</span> <span class="p">(</span><span class="n">w32Not</span> <span class="n">x</span> <span class="p">`</span><span class="n">w32And</span><span class="p">`</span> <span class="n">z</span><span class="p">)</span>

<span class="n">maj</span> <span class="o">::</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span>
<span class="n">maj</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">w32And</span><span class="p">`</span> <span class="n">y</span><span class="p">)</span> <span class="p">`</span><span class="n">w32Xor</span><span class="p">`</span> <span class="p">(</span><span class="n">x</span> <span class="p">`</span><span class="n">w32And</span><span class="p">`</span> <span class="n">z</span><span class="p">)</span> <span class="p">`</span><span class="n">w32Xor</span><span class="p">`</span> <span class="p">(</span><span class="n">y</span> <span class="p">`</span><span class="n">w32And</span><span class="p">`</span> <span class="n">z</span><span class="p">)</span>

<span class="n">bigsigma0</span> <span class="o">::</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span>
<span class="n">bigsigma0</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotateR2</span> <span class="n">x</span><span class="p">)</span> <span class="p">`</span><span class="n">w32Xor</span><span class="p">`</span> <span class="p">(</span><span class="n">rotateR13</span> <span class="n">x</span><span class="p">)</span> <span class="p">`</span><span class="n">w32Xor</span><span class="p">`</span> <span class="p">(</span><span class="n">rotateR22</span> <span class="n">x</span><span class="p">)</span>

<span class="n">bigsigma1</span> <span class="o">::</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span>
<span class="n">bigsigma1</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotateR6</span> <span class="n">x</span><span class="p">)</span> <span class="p">`</span><span class="n">w32Xor</span><span class="p">`</span> <span class="p">(</span><span class="n">rotateR11</span> <span class="n">x</span><span class="p">)</span> <span class="p">`</span><span class="n">w32Xor</span><span class="p">`</span> <span class="p">(</span><span class="n">rotateR25</span> <span class="n">x</span><span class="p">)</span>

<span class="n">sigma0</span> <span class="o">::</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span>
<span class="n">sigma0</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotateR7</span> <span class="n">x</span><span class="p">)</span> <span class="p">`</span><span class="n">w32Xor</span><span class="p">`</span> <span class="p">(</span><span class="n">rotateR18</span> <span class="n">x</span><span class="p">)</span> <span class="p">`</span><span class="n">w32Xor</span><span class="p">`</span> <span class="p">(</span><span class="n">shiftR3</span> <span class="n">x</span><span class="p">)</span>

<span class="n">sigma1</span> <span class="o">::</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span>
<span class="n">sigma1</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">rotateR17</span> <span class="n">x</span><span class="p">)</span> <span class="p">`</span><span class="n">w32Xor</span><span class="p">`</span> <span class="p">(</span><span class="n">rotateR19</span> <span class="n">x</span><span class="p">)</span> <span class="p">`</span><span class="n">w32Xor</span><span class="p">`</span> <span class="p">(</span><span class="n">shiftR10</span> <span class="n">x</span><span class="p">)</span>
</code></pre>
</div>

<p>The question now remains as to how we implement <code class="highlighter-rouge">w32Plus</code>, <code class="highlighter-rouge">w32And</code>, <code class="highlighter-rouge">w32Xor</code>, <code class="highlighter-rouge">w32Not</code>, and <code class="highlighter-rouge">incCtr</code>? For these operations, we choose to implement them directly in VHDL. Accomplishing this in ReWire comes in two parts: writing the type signatures of the operations using <code class="highlighter-rouge">nativeVhdl</code> and providing VHDL implementations of the operations in a separate file.</p>

<p>The following shows the first step (in <code class="highlighter-rouge">RWFirstImplementation.hs</code>):</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">w32Plus</span> <span class="o">::</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span>
<span class="cp">{-# INLINE w32Plus #-}</span>
<span class="n">w32Plus</span> <span class="o">=</span> <span class="n">nativeVhdl</span> <span class="s">"w32Plus"</span> <span class="n">w32Plus</span>

<span class="n">w32Xor</span> <span class="o">::</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span>
<span class="cp">{-# INLINE w32Xor #-}</span>
<span class="n">w32Xor</span>  <span class="o">=</span> <span class="n">nativeVhdl</span> <span class="s">"w32Xor"</span> <span class="n">w32Xor</span>

<span class="n">w32And</span> <span class="o">::</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span>
<span class="cp">{-# INLINE w32And #-}</span>
<span class="n">w32And</span>  <span class="o">=</span> <span class="n">nativeVhdl</span> <span class="s">"w32And"</span> <span class="n">w32And</span>

<span class="n">w32Not</span> <span class="o">::</span> <span class="kt">W32</span> <span class="o">-&gt;</span> <span class="kt">W32</span>
<span class="cp">{-# INLINE w32Not #-}</span>
<span class="n">w32Not</span> <span class="o">=</span> <span class="n">nativeVhdl</span> <span class="s">"w32Not"</span> <span class="n">w32Not</span>

<span class="n">incCtr</span> <span class="o">::</span> <span class="kt">Ctr</span> <span class="o">-&gt;</span> <span class="kt">Ctr</span>
<span class="cp">{-# INLINE incCtr #-}</span>
<span class="n">incCtr</span> <span class="o">=</span> <span class="n">nativeVhdl</span> <span class="s">"incCtr"</span> <span class="n">incCtr</span>
</code></pre>
</div>

<p>Above, the <code class="highlighter-rouge">nativeVhdl</code> keyword tells the ReWire compiler that it will find the implementations of these operations in a separate VHDL file. The second step defines each operation, as in the following file, <code class="highlighter-rouge">prims.vhd</code>:</p>

<figure class="highlight"><pre><code class="language-vhdl" data-lang="vhdl">library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package prims is
  pure function w32Plus (x : std_logic_vector; y : std_logic_vector) return std_logic_vector;
  pure function w32Xor (x : std_logic_vector; y : std_logic_vector) return std_logic_vector;
  pure function w32And (x : std_logic_vector; y : std_logic_vector) return std_logic_vector;
  pure function w32Not (x : std_logic_vector) return std_logic_vector;
  pure function incCtr (x : std_logic_vector) return std_logic_vector;
end prims;

package body prims is
  pure function w32Plus (x : std_logic_vector; y : std_logic_vector) return std_logic_vector is
  begin
    return (std_logic_vector(unsigned(x)+unsigned(y)));
  end w32Plus;

  pure function w32Xor (x : std_logic_vector; y : std_logic_vector) return std_logic_vector is
  begin
    return (x xor y);
  end w32Xor;

  pure function w32And (x : std_logic_vector; y : std_logic_vector) return std_logic_vector is
  begin
    return (x and y);
  end w32And;
  
  pure function w32Not (x : std_logic_vector) return std_logic_vector is
  begin
    return (not x);
  end w32Not;

  pure function incCtr (x : std_logic_vector) return std_logic_vector is
  begin
    return (std_logic_vector(unsigned(x)+1));
  end incCtr;
end prims;</code></pre></figure>

<h4 id="eliminating-type-synonyms"><strong>Eliminating <code class="highlighter-rouge">type</code> synonyms</strong></h4>

<p>There are two <code class="highlighter-rouge">type</code> synonyms used in <code class="highlighter-rouge">FirstImplementation.hs</code>; these are:
<code class="highlighter-rouge">haskell
type M = StateT (Oct Word32)
            (StateT (Hex Word32)
                (StateT (Oct Word32)
                    (StateT Ctr Identity)))
type Dev i o   = ReacT i o M
</code></p>

<p>This means that, in <code class="highlighter-rouge">RWFirstImplementation.hs</code>, each occurrence of <code class="highlighter-rouge">M</code> is replaced by:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>   <span class="kt">StT</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">Word32</span><span class="p">)</span> <span class="p">(</span><span class="kt">StT</span> <span class="p">(</span><span class="kt">Hex</span> <span class="kt">Word32</span><span class="p">)</span> <span class="p">(</span><span class="kt">StT</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">Word32</span><span class="p">)</span> <span class="p">(</span><span class="kt">StT</span> <span class="kt">Ctr</span> <span class="kt">I</span><span class="p">)))</span>
</code></pre>
</div>
<p>and each occurrence of <code class="highlighter-rouge">Dev Inp Out</code> is replaced by
<code class="highlighter-rouge">haskell
   ReT Inp Out (StT (Oct Word32) (StT (Hex Word32) (StT (Oct Word32) (StT Ctr I))))
</code>		  <br />
There are three small syntactic changes to note. In ReWire, the built-in type constructors for the state and reactive resumption monad transformers are <code class="highlighter-rouge">StT</code> and <code class="highlighter-rouge">ReT</code> (instead of <code class="highlighter-rouge">StateT</code> and <code class="highlighter-rouge">ReacT</code>). Also, as we have seen before, the built-in contructor for the identity monad in ReWire is <code class="highlighter-rouge">I</code> rather than <code class="highlighter-rouge">Identity</code>. Eliminating this distinction without a difference is another example of a small tweek to the language which is on our to-do list.</p>

<h4 id="adding-a-start-symbol"><strong>Adding a <code class="highlighter-rouge">start</code> symbol</strong></h4>

<p>The device specification in <code class="highlighter-rouge">RWFirstImplementation.hs</code> is identical to that of <code class="highlighter-rouge">FirstImplementation.hs</code>, although we affix an ` to it for ease of presentation:
<code class="highlighter-rouge">haskell
devsha256' :: ReT Inp Out (StT (Oct W32) (StT (Hex W32) (StT (Oct W32) (StT Ctr I)))) ()
devsha256' = signal Nix &gt;&gt;= \ i -&gt; dev i
</code>
This subsection illustrates how we produce a declaration compilable to VHDL from this.
The ReWire compiler can compile device expressions of type <code class="highlighter-rouge">ReT i o I t</code> for appropriate input, output, and return types, <code class="highlighter-rouge">i</code>, <code class="highlighter-rouge">o</code>, and <code class="highlighter-rouge">t</code>. So, clearly, some function must be applied to <code class="highlighter-rouge">devsha256</code> to produce something of the right type for the compiler. ReWire has a built-in function for doing just that called <code class="highlighter-rouge">extrude</code>.</p>

<p>The ReWire built-in function <code class="highlighter-rouge">extrude</code> is used to provide a device defined with <code class="highlighter-rouge">StT s</code> with an initial state of type <code class="highlighter-rouge">s</code>. For any monad <code class="highlighter-rouge">m</code>, it has type:
<code class="highlighter-rouge">haskell
extrude :: ReT i o (StT s m) a -&gt; s -&gt; ReT i o m (a,s)
</code>
In a call <code class="highlighter-rouge">(extrude dev s0)</code>, <code class="highlighter-rouge">extrude</code>, in effect, initializes the <code class="highlighter-rouge">s</code>-state to <code class="highlighter-rouge">s0</code> in device <code class="highlighter-rouge">dev</code>.
By using multiple applications of <code class="highlighter-rouge">extrude</code>, we can initialize all the states in a device specification. For <code class="highlighter-rouge">devsha256'</code>, this will require four applications of <code class="highlighter-rouge">extrude</code>. Therefore, we can define the <code class="highlighter-rouge">start</code> symbol as:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">start</span> <span class="o">::</span> <span class="kt">ReT</span> <span class="kt">Inp</span> <span class="kt">Out</span> <span class="kt">I</span> <span class="p">((((</span><span class="nb">()</span><span class="p">,</span> <span class="kt">Oct</span> <span class="kt">W32</span><span class="p">),</span> <span class="kt">Hex</span> <span class="kt">W32</span><span class="p">),</span> <span class="kt">Oct</span> <span class="kt">W32</span><span class="p">),</span> <span class="kt">Ctr</span><span class="p">)</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">extrude</span>
         <span class="p">(</span><span class="n">extrude</span>
           <span class="p">(</span><span class="n">extrude</span>
            <span class="p">(</span><span class="n">extrude</span>
                 <span class="n">devsha256'</span>
                 <span class="p">(</span><span class="kt">Oct</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span><span class="p">))</span>
                 <span class="p">(</span><span class="kt">Hex</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span><span class="p">))</span>
                 <span class="p">(</span><span class="kt">Oct</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span> <span class="n">w00000000</span><span class="p">))</span>
		 <span class="kt">C0</span>
</code></pre>
</div>

<p>In the above definition, we have initialize the intermediate digest register, the current block register, the digest register, and the counter register to appropriate forms of 0. Observe that <code class="highlighter-rouge">start</code> now possesses a type that the ReWire compiler can translate to VHDL.</p>

<h3 id="iv-second-implementation-refactoring-for-implementation">IV. Second Implementation: Refactoring for Implementation</h3>

<p>Recall that the inputs to the <code class="highlighter-rouge">devsha256</code> are 512 bits wide—i.e., a <code class="highlighter-rouge">Hex Word32</code> value requires 512 bits ($= 16 \times 32)$ to represent. Similarly, the <code class="highlighter-rouge">Oct Word32</code> outputs of <code class="highlighter-rouge">devsha256</code> require 256 ($= 8 \times 32$) bits to represent. 
Consequently, we would need an FPGA with at least 768 (= 512+256) I/O pins in order to synthesize devsha256 directly; this is an unrealistically large number. 
To bring the pin count down, we can refactor the devsha256 specification to marshal and unmarshal the input and output 64 bits at a time. If we want to target a smaller FPGA, then we can refactor the <code class="highlighter-rouge">devsha256'</code> specification to marshal and unmarshal the input and output to and from the board, thereby cutting the number of required I/O pins.</p>

<h4 id="marshaling-and-unmarshaling"><strong>Marshaling and Unmarshaling</strong></h4>

<p>The code below displays the new definitions of the <code class="highlighter-rouge">Inp</code> and <code class="highlighter-rouge">Out</code> data types to accomplish the marshaling and unmarshaling of data on and off the targeted board. Each load signal (i.e., either <code class="highlighter-rouge">Init</code> or <code class="highlighter-rouge">Load0</code> through <code class="highlighter-rouge">Load7</code>) contains two 32 bit words, so that words are loaded two at a time onto the targeted board. Each output digest signal (i.e., <code class="highlighter-rouge">DigestR</code>) off loads two 32 bit words per cycle, so that it takes four digest request signals (i.e., <code class="highlighter-rouge">DigestQ0</code> through <code class="highlighter-rouge">DigestQ3</code>) to output one digest. The calling convention for the new marshaling accelerator device changes as well, and it is defined similarly to the <code class="highlighter-rouge">format</code> function from the previous section (and can be found in <code class="highlighter-rouge">TestHarness.hs</code>). The code for the refactored device is found in <code class="highlighter-rouge">RWSecondImplementation.hs</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Inp</span> <span class="o">=</span> <span class="kt">Init</span> <span class="kt">Word32</span> <span class="kt">Word32</span>  <span class="o">|</span> <span class="kt">Load0</span> <span class="kt">Word32</span> <span class="kt">Word32</span> <span class="o">|</span> 
           <span class="kt">Load1</span> <span class="kt">Word32</span> <span class="kt">Word32</span> <span class="o">|</span> <span class="kt">Load2</span> <span class="kt">Word32</span> <span class="kt">Word32</span> <span class="o">|</span> 
           <span class="kt">Load3</span> <span class="kt">Word32</span> <span class="kt">Word32</span> <span class="o">|</span> <span class="kt">Load4</span> <span class="kt">Word32</span> <span class="kt">Word32</span> <span class="o">|</span> 
           <span class="kt">Load5</span> <span class="kt">Word32</span> <span class="kt">Word32</span> <span class="o">|</span> <span class="kt">Load6</span> <span class="kt">Word32</span> <span class="kt">Word32</span> <span class="o">|</span> 
           <span class="kt">Load7</span> <span class="kt">Word32</span> <span class="kt">Word32</span> <span class="o">|</span>
           <span class="kt">DigestQ0</span> <span class="o">|</span> <span class="kt">DigestQ1</span> <span class="o">|</span> <span class="kt">DigestQ2</span> <span class="o">|</span> <span class="kt">DigestQ3</span>
<span class="kr">data</span> <span class="kt">Out</span> <span class="o">=</span> <span class="kt">DigestR</span> <span class="kt">Word32</span> <span class="kt">Word32</span> <span class="o">|</span> <span class="kt">Nix</span>
</code></pre>
</div>

<p>The following is the new implementation, <code class="highlighter-rouge">devsha256''</code> that marshals and unmarshals data blocks off of the circuit. The loading and digest functions (i.e., <code class="highlighter-rouge">load0</code>, <code class="highlighter-rouge">digest0</code>, etc.) can be found in the ReWire specification <code class="highlighter-rouge">RWSecondImplementation.hs</code>.</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="n">devsha256''</span> <span class="o">::</span> <span class="kt">ReT</span> <span class="kt">Inp</span> <span class="kt">Out</span> <span class="p">(</span><span class="kt">StT</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">W32</span><span class="p">)</span> <span class="p">(</span><span class="kt">StT</span> <span class="p">(</span><span class="kt">Hex</span> <span class="kt">W32</span><span class="p">)</span> <span class="p">(</span><span class="kt">StT</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">W32</span><span class="p">)</span> <span class="p">(</span><span class="kt">StT</span> <span class="kt">Ctr</span> <span class="kt">I</span><span class="p">))))</span> <span class="nb">()</span>

<span class="n">devsha256''</span> <span class="o">=</span> <span class="kr">do</span> <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">signal</span> <span class="kt">Nix</span>
                 <span class="n">dev</span> <span class="n">i</span>

<span class="n">dev</span> <span class="o">::</span> <span class="kt">Inp</span> <span class="o">-&gt;</span> <span class="kt">ReT</span> <span class="kt">Inp</span> <span class="kt">Out</span> <span class="p">(</span><span class="kt">StT</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">W32</span><span class="p">)</span> <span class="p">(</span><span class="kt">StT</span> <span class="p">(</span><span class="kt">Hex</span> <span class="kt">W32</span><span class="p">)</span> <span class="p">(</span><span class="kt">StT</span> <span class="p">(</span><span class="kt">Oct</span> <span class="kt">W32</span><span class="p">)</span> <span class="p">(</span><span class="kt">StT</span> <span class="kt">Ctr</span> <span class="kt">I</span><span class="p">))))</span> <span class="nb">()</span>
<span class="n">dev</span> <span class="p">(</span><span class="kt">Init</span> <span class="n">w1</span> <span class="n">w2</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
                      <span class="n">lift</span> <span class="p">(</span><span class="kr">do</span>
                               <span class="n">putDigest</span> <span class="n">initialSHA256State</span>
                               <span class="n">hw</span> <span class="o">&lt;-</span> <span class="n">getBlock</span>
                               <span class="n">putBlock</span> <span class="p">(</span><span class="n">load0</span> <span class="n">w1</span> <span class="n">w2</span> <span class="n">hw</span><span class="p">))</span>
                      <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">signal</span> <span class="kt">Nix</span>
                      <span class="n">dev</span> <span class="n">i</span>
<span class="n">dev</span> <span class="p">(</span><span class="kt">Load0</span> <span class="n">w1</span> <span class="n">w2</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
                       <span class="n">lift</span> <span class="p">(</span><span class="kr">do</span>
                                <span class="n">hw</span> <span class="o">&lt;-</span> <span class="n">getBlock</span>
                                <span class="n">putBlock</span> <span class="p">(</span><span class="n">load0</span> <span class="n">w1</span> <span class="n">w2</span> <span class="n">hw</span><span class="p">))</span>
                       <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">signal</span> <span class="kt">Nix</span>
                       <span class="n">dev</span> <span class="n">i</span>
             <span class="o">...</span><span class="n">stuff</span> <span class="n">deleted</span><span class="o">...</span>
<span class="n">dev</span> <span class="p">(</span><span class="kt">Load7</span> <span class="n">w1</span> <span class="n">w2</span><span class="p">)</span> <span class="o">=</span> <span class="kr">do</span>
                       <span class="n">lift</span> <span class="p">(</span><span class="kr">do</span>
                                <span class="n">putCtr</span> <span class="kt">C0</span>
                                <span class="n">hi_1</span> <span class="o">&lt;-</span> <span class="n">getDigest</span>
                                <span class="n">putIntDig</span> <span class="n">hi_1</span>
                                <span class="n">hw</span> <span class="o">&lt;-</span> <span class="n">getBlock</span>
                                <span class="n">putBlock</span> <span class="p">(</span><span class="n">load7</span> <span class="n">w1</span> <span class="n">w2</span> <span class="n">hw</span><span class="p">))</span>
                       <span class="n">signal</span> <span class="kt">Nix</span>
                       <span class="n">innerloop</span>
<span class="n">dev</span> <span class="kt">DigestQ0</span>      <span class="o">=</span> <span class="kr">do</span>
                       <span class="n">h_n</span> <span class="o">&lt;-</span> <span class="n">lift</span> <span class="n">getDigest</span>
                       <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">signal</span> <span class="p">(</span><span class="n">digest0</span> <span class="n">h_n</span><span class="p">)</span>
                       <span class="n">dev</span> <span class="n">i</span>
             <span class="o">...</span><span class="n">stuff</span> <span class="n">deleted</span><span class="o">...</span>
<span class="n">dev</span> <span class="kt">DigestQ3</span>      <span class="o">=</span> <span class="kr">do</span>
                       <span class="n">h_n</span> <span class="o">&lt;-</span> <span class="n">lift</span> <span class="n">getDigest</span>
                       <span class="n">i</span> <span class="o">&lt;-</span> <span class="n">signal</span> <span class="p">(</span><span class="n">digest3</span> <span class="n">h_n</span><span class="p">)</span>
                       <span class="n">dev</span> <span class="n">i</span>
</code></pre>
</div>

<h4 id="synthesis"><strong>Synthesis</strong></h4>

<p>The <code class="highlighter-rouge">devsha256''</code> accelerator has been tested in Haskell to show that it computes the same hashes as the reference semantics. 
Using the ReWire compiler, we can produce synthesizable VHDL and synthesize to a FPGA target — here we target the Xilinx Spartan-3E XC3S500E-4FG320 featured on the Xilinx Spartan-3E Starter Kit. 
Note that this board possesses sufficient I/O pins to accommodate <code class="highlighter-rouge">devsha256''</code>.</p>

<p>The table below presents the synthesis numbers for <code class="highlighter-rouge">devsha256''</code> for the Xilinx ISE toolset targeting the Spartan-3E. The maximum clock rate was 60 MHz.
<img src="/images/SHA256-performance.pdf" style="display: block; margin: 0 auto;" height="50" alt="Screenshot" />
There are 76 cycles per output, and so the total throughput for <code class="highlighter-rouge">devsha256''</code> is calculated as:</p>

<script type="math/tex; mode=display">(60 \mathit{MHz} \times 512 \mathit{bits}) / 76 \mathit{cycles} = 404 \mathit{Mbps}</script>

<p>This throughput for the <code class="highlighter-rouge">devsha256''</code> accelerator is on the low end of the performance spectrum of the hand-crafted VHDL implementations reported in <a href="http://link.springer.com/chapter/10.1007%2F11894063_24">Chaves06</a> — higher than Sklavos and Koufopavlou <a href="http://link.springer.com/article/10.1007%2Fs11227-005-0086-5">Sklavos05</a> (376 <em>Mbps</em>) and lower than Chaves et al. (1370 <em>Mbps</em>).
The aforementioned prior works are not targeting the same FPGA, and so the above is something of a sort of "apples-to-oranges" comparison.
The performance numbers should be taken merely as indicative that performance is reasonable for a rapidly developed prototype.</p>


                    </div>
                
            </div>

            

            <div class="row">
                <div id="footer" class="col-sm-12">
                    Documentation for <a href="https://github.com/mu-chaco/ReWire">William L. Harrison, Ph.D</a>

                </div>
            </div>
        </div>

        <script>
            function orderNav() {
                var list,
                    section,
                    header,
                    sections = [],
                    lists = {},
                    headers = {};

                var navUl = document.querySelectorAll('#navigation ul')[0],
                    navLis = document.querySelectorAll('#navigation ul li');

                if (!navUl) return;

                for (var i = 0; i < navLis.length; i++) {
                    var order, li = navLis[i];

                    if (li.classList.contains('nav-header')) {
                        section = li.textContent || li.innerText;
                        sections.push(section);
                        headers[section] = li;
                        continue;
                    }

                    if (!lists[section]) {
                        lists[section] = [];
                    }

                    order = parseFloat(li.getAttribute('data-order'))
                    lists[section].push([order, li]);
                }

                for (var i = 0; i < sections.length; i++) {
                    section = sections[i];
                    list = lists[section].sort(function(a, b) {
                        return a[0] - b[0];
                    });

                    if (header = headers[section]) {
                        navUl.appendChild(header);
                    }
                    for (var j = 0; j < list.length; j++) {
                        navUl.appendChild(list[j][1]);
                    }
                }
            }

            if (document.querySelectorAll) orderNav();
        </script>
        
    </body>
</html>
