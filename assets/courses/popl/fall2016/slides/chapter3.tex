\documentclass{beamer}

\usepackage{listings,color}

\input{globals}
%\usetheme{Singapore}
%\useoutertheme{myinfolines}
\usecolortheme{rose}

%\usecolortheme{seahorse}
\useinnertheme[shadow]{rounded} 
\setbeamertemplate{navigation symbols}{}

\usepackage[all]{xy}
\usepackage{xmpmulti}
%\usepackage{pdfpages}

\newenvironment{codeblock}[1][.8]{%
\begin{columns}
\begin{column}{#1\linewidth}
\begin{exampleblock}{}}{%
\end{exampleblock}
\end{column}
\end{columns}} 

\newenvironment{execblock}[1][.8]{%
\begin{columns}
\begin{column}{#1\linewidth}
\begin{block}{}}{%
\end{block}
\end{column}
\end{columns}} 

\def\slideskip{\vskip 0.1in}
\def\frameskip{\vskip 0.1in}


%\begin{frame}
%\begin{figure}[t]
%\includegraphics[width=1\textwidth]{example1.png}
%\end{figure}
%\end{frame}

\title[CS4450]{CS4450/7450\\Chapter 3: Types and Type Classes}
\subtitle{Principles of Programming Languages}
\author[Bill Harrison]{Dr. William Harrison}
\institute{University of Missouri}
%\date{August 31, 2011}

\begin{document}

\frame{\titlepage}

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Let the type be your guide}

What is the type of \verb+foo+?
\begin{codeblock}
\begin{hcode}
foo st = [ c | c <- st, c `elem` ['A'..'Z']] 
\end{hcode}
\end{codeblock}

\vfill
\pause
What does \verb+foo+ do?
\begin{codeblock}
\begin{hcode}
foo :: [Char] -> [Char]  
foo st = [ c | c <- st, c `elem` ['A'..'Z']] 
\end{hcode}
\end{codeblock}

\pause
\begin{codeblock}
\begin{hcode}
ghci> foo "A Connecticut Yankee in King Arthur's Court"
"ACYKAC"
\end{hcode}
\end{codeblock}

\end{frame}
%%%%%%%%%
%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Type Systems}
\framesubtitle{Haskell has ``static types with inference''}

\begin{itemize}
\item {\bf Type Checking:} given an expression $e$ and a type $t$, check whether $e :: t$. E.g., 
\begin{hcode}
("hey", True) :: (String,Bool) -- Yes!
("hey", True) :: (String,Char) -- No!
\end{hcode}

\pause
\item {\bf{Type Inference:}} given an expression $e$, compute its type $t$ (if it exists). E.g., 
\begin{hcode}
("hey",True)   %$\leadsto$%  (String,Bool)
"hey" + 99     %$\leadsto$%  error!
\end{hcode}

\pause 
\item {\bf Static Types.} a type system for which the types of expressions are known at \emph{compile-time}. I.e., the type of every expression is known by inspecting its code---and not by running it.
\end{itemize}

\end{frame}
%%%%%%%%%
%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Type Variables}
\framesubtitle{Reintroducing what we called ``parametric polymorphism''}

The following type means that, for all types \verb+a+ and \verb+b+, the function \verb+fst+ can be applied.
%\begin{codeblock}
\begin{hcode}
ghci> :t fst  
fst :: (a, b) -> a 
\end{hcode}
%\end{codeblock}

\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Type Instances}

Given:
%\begin{codeblock}
\begin{hcode}
ghci> :t fst  
fst :: (a, b) -> a 
\end{hcode}
%\end{codeblock}

``Instances'' of \verb+(a,b) -> a+ determine how \verb+fst+ can be applied:
\begin{hcode}
  (Int,Char) -> Int                -- %\color{red}{fst}% (99,'A')
  ([Char],Float) -> [Char]         -- %\color{blue}{fst}% ("Hey",3.14)
  (Int -> Int,Bool) -> Int -> Int  -- %\color{green}{fst}% (id,True)
                  %$\vdots$%
\end{hcode}

{\tt{\color{red}{fst}}}, 
{\tt{\color{blue}{fst}}}, 
{\tt{\color{green}{fst}}} all refer to {\bf the same code}.

\end{frame}
%%%%%%%%%
%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Type Classes}

The {\color{red}{following}} is a \emph{type constraint}:
\begin{hcode}
ghci> :t (==)  
(==) :: %\color{red}{(Eq a) =>}% a -> a -> Bool 
\end{hcode}

\vfill
It means that \verb+(==)+ can be applied only at types in the \verb+Eq+ class.

\vfill There are many predefined classes in Haskell, including
\verb+Ord+, \verb+Show+, \verb+Enum+, \verb+Num+, etc.

\end{frame}
%%%%%%%%%
%%%%%%%%%

\end{document}
