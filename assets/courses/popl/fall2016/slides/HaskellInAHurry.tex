\documentclass{beamer}

%\usetheme{Malmoe}
\usetheme{Szeged}
\usecolortheme{crane}

\newtheorem{remark}{Remark}

\usepackage{listings}
\usepackage{beamerthemesplit}
\setbeamertemplate{navigation symbols}{}
\lstnewenvironment{newcode}{\lstset{language=Haskell,basicstyle=\scriptsize,escapechar=\@}}{}
\newcommand{\ttcode}[1]{{\color{red}{\tt{#1}}}}

\newcommand{\forget}[1]{}
\title{CS4450/7450: Haskell in a Hurry}
\author{Bill Harrison}
\date{\today}

\begin{document}

\frame{\titlepage}

\forget{
\section[Outline]{}
\frame{\tableofcontents}

\section{Introduction}
%\subsection{Overview of the Beamer Class}
\frame
{
  \frametitle{Features of the Beamer Class}

  \begin{itemize}
  \item<1-> Normal LaTeX class.
  \item<2-> Easy overlays.
  \item<3-> No external programs needed.      
  \end{itemize}
}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frame
{
    \frametitle{Haskell Basics}
\begin{itemize}
\item Modern (pure) lazy functional language
\item Statically typed, supports type inference
\item Compilers and interpreters:
\begin{itemize}
\item http://www.haskell.org/implementations.html
\item Hugs interpreter
\item GHC Compiler
\end{itemize}
\item A peculiar language feature: indentation matters
\item Also: capitalization matters
\end{itemize}
}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Type inference}
\begin{itemize}
\item 
{\color{red}\verb^x = 1 + 2^}
\item[] {\color{red}\verb^1^} has type {\color{red}\verb^Integer^}, {\color{red}\verb^2^} has type {\color{red}\verb^Integer^}, adding two Integers
%
%\item[]
results in another \ttcode{Integer}, therefore  \ttcode{x :: Integer}. \footnote{Actually, member of {\tt Num} type class  is inferred; but, {\tt Integer} $\in$ {\tt Num}.}

\pause
\item
{\color{red}\verb^inc x = x + 1^}
With similar reasoning, {\color{red}\verb^inc :: Integer -> Integer^}
\pause

\item Explicit type annotations are possible:
{\color{red}\begin{verbatim}
inc :: Integer -> Integer
inc x = x + 1
\end{verbatim}
}

\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Lists in Haskell}
\begin{itemize}
\item The data-structure for almost everything is List

\item Constructing lists:
{\color{red}
\begin{newcode}
[]        -- @empty list@
[1]       -- @list with one element@
[1, 2, 3] -- @a longer list@
\end{newcode}
}
\pause

\item List patterns:
\begin{itemize}
\item \ttcode{x:xs} matches to any list with one or more elements
\item \ttcode{x:y:z:xs} matches to any list with three or more elements
\item \ttcode{[x]} matches to any list with one element
\item \ttcode{[]} matches to empty list
\end{itemize}
\pause

\item[]

{\color{red}
\begin{newcode}
let x:xs = [1, 2, 3]
 -- x is 1
 -- xs is [2, 3]
\end{newcode}
}

\end{itemize}


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Defining Functions}
\begin{itemize}

\item Defined as equations (with pattern matching)
{\color{red}
\begin{newcode}
len1::[a] -> Integer
len1 [] = 0
len1 (x:xs) = 1 + len1 xs
\end{newcode}
}
\pause

\item With lambda abstraction
{\color{red}
\begin{newcode}
len2::[a] -> Integer
len2 = \ x -> if (null x) then 0 else 1 + (len2 (tail x))
\end{newcode}
}

\pause
\item Note the function invocation syntax:
{\color{red}
\begin{newcode}
(len1 [1, 2, 3])
\end{newcode}
}

\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Haskell functions can be \emph{curried}}
{\large
    {\color{red}
    \begin{newcode}
    add::Int -> Int -> Int
    add x y = x + y
    
    add3::Int -> Int
    add3 = add 3
    
    z::Int
    z = add3 4
    \end{newcode}
    }
}
\pause
Different Function:
\begin{newcode}
add' :: (Int,Int) -> Int
add' (i,j) = i+j
\end{newcode}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Haskell is \emph{pure}}
\begin{itemize}
\item I.e., no side effects (e.g. assignments, etc.). For example, in 
{\color{red}
\begin{verbatim}
x = add 1 2 
\end{verbatim}
}
\begin{itemize}
\item a fresh variable \ttcode{x} is bound to the value of \ttcode{add 1 2},
\item the value of \ttcode{add 1 2} is not computed until the value of \ttcode{x} is required (\emph{lazy evaluation}), 
\item \ttcode{x} stays bound to \ttcode{add 1 2}  within the scope of definition. 
\item Not an assignment!
\end{itemize}

\pause
\item \(\therefore\) Haskell functions are pure "mathematical" functions 
\begin{itemize}
\item Makes reasoning about programs feasible 
\item N.b., side-effects are necessary for realistic programming (for 
IO, efficiency, ...). 

\item Haskell type system encapsulates all effects inside 
\emph{monads} 

\end{itemize}
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Haskell is \emph{lazy}}
\begin{itemize}
\item Lazy evaluation (a.k.a., call-by-need): 
Never evaluate an expression, unless itÕs value is needed 

\item
Example: The following program is not erroneous. 
{\color{red}
\begin{verbatim}
omit x = 0 
v      = omit (1/0) 
main   = putStr (show v) 
\end{verbatim}
}
\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Parametric Polymorphism}
\begin{itemize}
\item Examples: 
{\color{red}
\begin{verbatim}
id :: a -> a 
id x = x 

length :: [a] -> Int 
length []     = 0 
length (x:xs) = 1 + length xs
 
tail :: [a] -> [a] 
tail []     = [] 
tail (x:xs) = xs 

eval::(a -> b) -> a -> b 
eval f x = f x 
\end{verbatim}
}
\item Note syntax for type parameters 
\end{itemize}
\end{frame}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Type Classes}
\begin{itemize}
\item Consider now a non-parameterically polymorphic function. 
{\color{red}
\begin{verbatim}
not_equal:: a -> a -> Bool ??? 
not_equal x y = if (x == y) then False else True 
\end{verbatim}
}

\pause
\item There are requirements for \ttcode{a};  
Not all \ttcode{a}'s will be acceptable. 

\pause
\item The type bound to \ttcode{a} must be \emph{equality 
comparable}

\pause
\item
\ttcode{a} must be an instance of the type class \ttcode{Eq}
{\color{red}
\begin{verbatim}
not_equal:: Eq a => a -> a -> Bool 
not_equal x y = if (x == y) then False else True 
\end{verbatim}
}

\end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Motivating Type Classes}
\begin{itemize}
\item Primary motivation: Function overloading mechanism for Haskell 
(ad-hoc polymorphism)\footnote{Wadler, Blott: "How to Make Ad-Hoc Polymorphism Less Ad Hoc", 1988} 
\begin{itemize}
\item Overloading with type classes is akin to OO overloading
\end{itemize}
\item Two different kinds of polymorphism in Haskell
\begin{itemize}
\item Parametric polymorphism: one implementation covers all types 
\item Ad-hoc polymorphism: same syntax for different implementations 
\end{itemize}

\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Type Classes (cont'd)}
\begin{itemize}
\item Type classes represent a set of requirements 
\item Requirements are expressed as function signatures 
\item Default implementations for each signature can be provided 
\item Example: 
{\color{red}
\begin{verbatim}
class Eq a where 
   (==), (/=) :: a -> a -> Bool 
\end{verbatim}
}
%   x /= y     = not (x == y) 
%   x == y     = not (x /= y) 

\item 
The class definition can be read as: 
{\it A class of types that conforms to the specified interface}

\item
Note how the declaration of conformance is separate from the 
definition of a type (unlike, say, \ttcode{implements} in Java) 
\end{itemize}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Instances of Type Classes}
\begin{itemize}
\item Members of type classes are called \emph{instances}. 
A type is not an instance of a type class unless explicitly defined as such:
{\color{red}
\begin{verbatim} 
instance Eq Bool where 
   True == True   = True 
   False == False = True 
   _ == _         = False 
\end{verbatim}
}

\item
This would be painful without parameterized instance declarations, 
referred to as "conditional instance declarations". Example: 
{\color{red}
\begin{verbatim}
instance Eq a => Eq [a] where 
    [] == []         = True 
    (x:xs) == (y:ys) = x==y && xs==ys 
     _ == _          = False 
\end{verbatim}
}

\item
\ttcode{Eq a =>} is the context (constraint). 

\end{itemize}

\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Constraining polymorphic functions}
\begin{itemize}
\item
If a function is not explicitly annotated with its type, constraints will 
be deduced with type inference 
{\color{red}
\begin{verbatim}
not_equal x y = if (x == y) then False else True 
\end{verbatim}
}

\item
From \ttcode{x == y} it can be inferred that the types of \ttcode{x} and \ttcode{y} must be 
instances of \ttcode{Eq}, and they must be of the same type. 

\item
The type of \verb@not_equal@ is thus deduced to: 
{\color{red}
\begin{verbatim}
not_equal :: Eq a => a -> a -> Bool 
\end{verbatim}
}

\item
Type inference determines the least constrained function type 
(a.k.a., principal type). 

\item Type annotations are an important form of documentation
\begin{itemize}
\item annotations are (usually) not essential
\item sometimes must to help the type inference process (polymorphic recursion) 
\end{itemize}

\item Consequence of type inference: a particular function name, such as \ttcode{==} 
can only be required by one type class.
\end{itemize}
\end{frame}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Inheritance in type classes }
\begin{itemize}
\item
$\ldots$ is comparable to extending interfaces in 
Java 

\item
Accomplished with conditional class definitions. 

\item
The same syntax Eq a for expressing the context is used. 
{\color{red}
\begin{verbatim}
class Eq a => Ord a where 
   (<), (<=), (>), (>=) :: a -> a -> Bool 
   max, min             :: a -> a -> a 
   compare              :: a -> a -> Ordering 
\end{verbatim}
}

\item
To be an instance of \ttcode{Ord}, type must meet the signature requirements 
listed in \ttcode{Ord} and those of \ttcode{Eq}. 

\item
An instance declaration that makes a type an instance of \ttcode{Ord} does not 
establish that the type is an instance of \ttcode{Eq}! 

\end{itemize}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Multiple type class constraints}
\begin{itemize}
\item 
A single type parameter can be constrained with several type classes. 

\item
E.g. a function that needs to compare values, and also show them as 
strings: 
{\color{red}
\begin{verbatim}
class Show a where 
    show     :: a -> String 
    show_min :: (Ord a, Show a) => a -> a -> String 
    show_min x y = show (min x y) 
\end{verbatim}
}

\end{itemize}
\end{frame}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
    \frametitle{Modules, Data Types, Libraries}
\begin{itemize}
\item \ttcode{data} vs. \ttcode{newtype} vs. \ttcode{type}

\item records, tuples, lists 

\item \ttcode{import}

\end{itemize}
\end{frame}



\end{document}
    
