\documentclass{beamer}

\usepackage{listings,color}

\input{globals}
%\usetheme{Singapore}
\usetheme{Berkeley}
%\useoutertheme{myinfolines}
\usecolortheme{rose}

%\usecolortheme{seahorse}
\useinnertheme[shadow]{rounded} 
\setbeamertemplate{navigation symbols}{}

\usepackage[all]{xy}
\usepackage{xmpmulti}

%\usepackage{pdfpages}

\newenvironment{codeblock}[1][.8]{%
\begin{columns}
\begin{column}{#1\linewidth}
\begin{exampleblock}{}}{%
\end{exampleblock}
\end{column}
\end{columns}} 

\newenvironment{execblock}[1][.8]{%
\begin{columns}
\begin{column}{#1\linewidth}
\begin{block}{}}{%
\end{block}
\end{column}
\end{columns}} 

\def\slideskip{\vskip 0.1in}
\def\frameskip{\vskip 0.1in}


%\begin{frame}
%\begin{figure}[t]
%\includegraphics[width=1\textwidth]{example1.png}
%\end{figure}
%\end{frame}

\title[CS4450]{CS4450/7450\\Chapter 4: Syntax in Functions}
\subtitle{Principles of Programming Languages}
\author[Bill Harrison]{Dr. William Harrison}
\institute{University of Missouri}
%\date{August 31, 2011}

\begin{document}

\frame{\titlepage}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Pattern Matching}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{What is a Pattern?}

\begin{codeblock}
\begin{hcode}
data I = A | B | C
foo :: I -> String
foo %\color{red}{A}% = "One"
foo %\color{red}{B}% = "Two"
foo %\color{red}{C}% = "Three"
\end{hcode}
\end{codeblock}
\vfill

A \emph{pattern} is anything in the {\color{red}{argument position}} of a function definition. \pause
There are:
\begin{itemize}
\item variable patterns, wildcard patterns, constructor patterns, as-patterns
\end{itemize}
...and bigger patterns are composed of smaller patterns.

\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Wildcard Patterns}

The underscore ``\verb+_+'' is a wildcard pattern. They match anything.

\begin{codeblock}
\begin{hcode}
first :: (a, b, c) -> a  
first (x, _, _) = x  
  
second :: (a, b, c) -> b  
second (_, y, _) = y  
  
third :: (a, b, c) -> c  
third (_, _, z) = z 
\end{hcode}
\end{codeblock}
\vfill

Wildcards are good to use to indicate that you don't care about the value it matches.

\end{frame}
%%%%%%%%%
%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Variable Patterns}

Variable patterns match anything:
%\begin{codeblock}
\begin{hcode}
addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
addVectors %\color{red}{a b}% = (fst a + fst b, snd a + snd b)  
\end{hcode}
%\end{codeblock}

\pause
\vfill
In the following application, \verb+a+ and \verb+b+ are bound to
 \verb+(5,6)+ and \verb+(7,8)+, respectively.
%\begin{codeblock}
\begin{hcode}
addVectors (5,6) (7,8) 
\end{hcode}
%\end{codeblock}
\vfill

\pause 
Can also express structure of the input directly using patterns:
%\begin{codeblock}
\begin{hcode}
addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)  
addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)  
\end{hcode}
%\end{codeblock}

\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Constructor Patterns}

Recall that lists have two constructors:
\begin{hcode}
data [a] = [] | (a : [a])
\end{hcode}

\pause

Constructors, when appearing in argument position, are patterns:
\begin{hcode}
length :: (Num b) => [a] -> b  
length %\color{red}{[]}%     = 0  
length %\color{red}{(\_:xs)}% = 1 + length xs  
\end{hcode}


\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Composite Patterns}

Patterns can be composed to make bigger patterns, thereby giving you more expressiveness in matching values:
\begin{hcode}
tell :: (Show a) => [a] -> String  
tell []       = "The list is empty"  
tell (x:[])   = "The list has one element: " ++ show x  
tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y  
tell (x:y:_)  = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y
\end{hcode}


\end{frame}
%%%%%%%%%
%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{As Patterns}

Here, ``as'' is \verb+@+
\begin{codeblock}
\begin{hcode}
capital :: String -> String  
capital "" = "Empty string, whoops!"  
capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x] 
\end{hcode}
\end{codeblock}

\begin{codeblock}
\begin{hcode}
ghci> capital "Dracula"  
"The first letter of Dracula is D" 
\end{hcode}
\end{codeblock}

\end{frame}
%%%%%%%%%
%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Guards in Patterns}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Guards}

It's easy enough to write the maximum function using 
\verb+if-then-else+:
\begin{codeblock}
\begin{hcode}
max :: Float -> Float -> Float
max a b = if a<b then b else a
\end{hcode}
\end{codeblock}
\vfill

\pause
Another way to define the identical function is with \emph{guards}:
\begin{codeblock}
\begin{hcode}
max :: Float -> Float -> Float
max a b | a<b       = b
        | otherwise = a
\end{hcode}
\end{codeblock}


\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Why use guards: Readability.}

This is much more readable:
%\begin{codeblock}
\begin{hcode}
bmiTell :: (RealFloat a) => a -> String  
bmiTell bmi  
    | bmi <= 18.5 = "underweight"  
    | bmi <= 25.0 = "normal"  
    | bmi <= 30.0 = "overweight"  
    | otherwise   = "obese"
\end{hcode}
%\end{codeblock}
\vfill
\pause
...than this:
%\begin{codeblock}
\begin{hcode}
bmiTell :: (RealFloat a) => a -> String  
bmiTell bmi = if bmi <= 18.5
               then "underweight"
                else if bmi <= 25.0
                      then "normal"  
                else if bmi <= 30.0
                      then "overweight"
                else
                      "obese"  
\end{hcode}
%\end{codeblock}



\end{frame}
%%%%%%%%%
%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Where Clauses}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Where clauses}
\framesubtitle{let you define local variables}

\begin{hcode}
bmiTell :: (RealFloat a) => a -> a -> String  
bmiTell weight height  
    | weight / height ^ 2 <= 18.5 = "underweight"  
    | weight / height ^ 2 <= 25.0 = "normal"  
    | weight / height ^ 2 <= 30.0 = "overweight"  
    | otherwise                   = "obese"
\end{hcode}
\pause

\begin{hcode}
bmiTell :: (RealFloat a) => a -> a -> String  
bmiTell weight height  
    | bmi <= 18.5 = "underweight"  
    | bmi <= 25.0 = "normal"  
    | bmi <= 30.0 = "overweight"  
    | otherwise   = "obese"
  where
     bmi = weight / height ^ 2
     -- calculate bmi once, use value repeatedly
\end{hcode}

\end{frame}
%%%%%%%%%
%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Let Bindings}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Let definitions}
\framesubtitle{...are just like where clauses}

\begin{hcode}
cylinder :: (RealFloat a) => a -> a -> a  
cylinder r h = 
    let 
        sideArea = 2 * pi * r * h  
        topArea  = pi * r ^2  
    in  
        sideArea + 2 * topArea 
\end{hcode}

\begin{itemize}
\item Variables defined in a \verb+let+ or \verb+where+ clauses are local
\item E.g., \verb+sideArea+ and \verb+topArea+ can be used only in the body of the \verb+let/where+.
\end{itemize}

\end{frame}
%%%%%%%%%
%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Case Expressions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Case Expressions}

General form of a case expression:
\begin{hcode}
case expression of pattern -> result  
                   pattern -> result  
                   pattern -> result  
                   ...  
\end{hcode}
\pause\vfill
\begin{hcode}
head :: [a] -> a  
head []    = error "empty list"  
head (x:_) = x 
\end{hcode}

\pause\vfill
A way to define the identical function:
\begin{hcode}
head :: [a] -> a  
head xs = case xs of 
               []    -> error "empty list"  
               (x:_) -> x  
\end{hcode}


\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{}

\begin{codeblock}
\begin{hcode}

\end{hcode}
\end{codeblock}

\end{frame}
%%%%%%%%%
%%%%%%%%%
\end{document}
