\documentclass{beamer}

\usepackage{listings,color}
\usepackage{haskell}
\input{globals}
%\usetheme{Singapore}
\usetheme{Berkeley}
%\useoutertheme{infolines}
\usecolortheme{rose}

%\usecolortheme{seahorse}
\useinnertheme[shadow]{rounded} 
\setbeamertemplate{navigation symbols}{}

\usepackage[all]{xy}
\usepackage{xmpmulti}

%\usepackage{pdfpages}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=red,
}
 
\urlstyle{same}

\newenvironment{codeblock}[1][.8]{%
\begin{columns}
\begin{column}{#1\linewidth}
\begin{exampleblock}{}}{%
\end{exampleblock}
\end{column}
\end{columns}} 

\newenvironment{execblock}[1][.8]{%
\begin{columns}
\begin{column}{#1\linewidth}
\begin{block}{}}{%
\end{block}
\end{column}
\end{columns}} 

\def\slideskip{\vskip 0.1in}
\def\frameskip{\vskip 0.1in}


%\begin{frame}
%\begin{figure}[t]
%\includegraphics[width=1\textwidth]{example1.png}
%\end{figure}
%\end{frame}

\title[CS4450]{CS4450/7450\\AoPL, Chapter 3: Variables}
\subtitle{Principles of Programming Languages}
\author[Bill Harrison]{Dr. William Harrison}
\institute{University of Missouri}
%\date{August 31, 2011}

\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
\frametitle{Announcements}

\begin{itemize}
\item HW4 due today (already)

\item We're starting to use William Cook's online textbook, \emph{Anatomy of Programming Languages}. It is available
\href{https://www.cs.utexas.edu/~wcook/anatomy/}{here}. We're in Chapter 3.
\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Object Language vs. Metalanguage}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Object vs. Meta}

In each of the interpreters we have written so far, there have been really {\bf two} languages:
\begin{codeblock}
\begin{hcode}
module ArithAST where

data Op    = Plus | Minus | Times | Div 
data Exp   = Const Int | Aexp Op Exp Exp 
\end{hcode}
\end{codeblock}

\pause
\begin{itemize}
\item Object Language: this is the language being studied
\begin{itemize}
\item Here, that of arithmetic expressions
\end{itemize}
\item Metalanguage: the language of description/implementation
\begin{itemize}
\item Here, Haskell
\end{itemize}
\end{itemize}

\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Variables}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{What is a Variable?}

\begin{itemize}
\item {\bf{Variable}}: a symbol referring to a value
\vfill

\item Full code \href{https://harrisonwl.github.io/assets/courses/popl/fall2016/aopl/code/Substitute.hs.htm}{here}:
\begin{codeblock}
\begin{hcode}
data Exp  = Number    Int
          | Add       Exp Exp
          | Subtract  Exp Exp
          | Multiply  Exp Exp
          | Divide    Exp Exp
          | Variable  String  -- added
   deriving (Eq, Show)
\end{hcode}
\end{codeblock}

\vfill
\item {\bf Binding:} Association of a variable with a value
\begin{itemize}
\item sometimes written $x \mapsto v$
\end{itemize}

\end{itemize}


\end{frame}
%%%%%%%%%
%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Mutation}

\begin{itemize}
\item ``Mathematical variables'' vary by \emph{context}
\pause
\begin{itemize}
\item E.g., \textcolor{red}{$x$} and \textcolor{blue}{$x$} vary because they are in different contexts:
\begin{haskell}
\textcolor{red}{x}^2 + 2\textcolor{red}{x} + 9 = 0
\\
\textcolor{blue}{x}^2 - 5\textcolor{blue}{x} - 7 = 0
\end{haskell}
\end{itemize}

\pause

\item ``Program Variables'' \emph{mutate} --- they are really \emph{containers}
\item For example, \textcolor{green}{x} contains a number of values in the same context:
\begin{hcode}
   x = 0; while (%\textcolor{green}{x}%++ < 10) { ... } 
\end{hcode}

\end{itemize}

\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Substitution}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Substitution}
Substitution replaces a variable with a value in an expression. 
\vfill
\begin{tabular}{|c|c|c|}
\hline
Substitution & Expression & Produces\\
\hline\hline
$x \mapsto 5$ & $x+2$ & $5+2$
\\
$x \mapsto 5$ & $2$ & $2$
\\
$x \mapsto 5$ & $x$ & $5$
\\
$x \mapsto 5$ & $x*x+x$ & $5*5+5$
\\
$x \mapsto 5$ & $x+y$ & $5+y$
\\\hline
\end{tabular}

\vfill\pause
N.b., if the variable names don't match, they are left alone
\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Substitution Implementation}

The following code implements this behavior:
\vfill
%\begin{codeblock}
\begin{tinycode}
substitute1:: (String, Int) -> Exp -> Exp
substitute1 (var, val) exp = subst exp where
  subst (Number i)      = Number i
  subst (Add a b)       = Add (subst a) (subst b)
  subst (Subtract a b)  = Subtract (subst a) (subst b)
  subst (Multiply a b)  = Multiply (subst a) (subst b)
  subst (Divide a b)    = Divide (subst a) (subst b)
  subst (Variable name) = if var == name
                          then Number val
                          else Variable name
\end{tinycode}
%\end{codeblock}

Can run tests using this \href{https://harrisonwl.github.io/assets/courses/popl/fall2016/aopl/code/SubstituteTest.hs.htm}{code}.

\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Multiple Substitution using Environments}
%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Multiple Bindings}

\begin{itemize}
\item Obviously, some expressions have multiple variables; e.g., $2 * x + y$ with $x\mapsto 3$ and $y\mapsto -2$.

\pause
\item {\bf Environment}: collection of multiple bindings

\pause
\item Represent Environments in Haskell with 
\begin{codeblock}
\begin{hcode}
type Env = [(String,Int)]

-- for expression above
e1 = [("x",3),("y",-2)]
\end{hcode}
\end{codeblock}

\pause
\item Looking up variables in an Env
\begin{hcode}
lookup :: Eq a => a -> [(a,b)] -> Maybe b
lookup a [] = Nothing
lookup a ((a',b):bs) 
    | a==a'     = Just b
    | otherwise = lookup a bs
\end{hcode}

\end{itemize}

\end{frame}
%%%%%%%%%
%%%%%%%%%


%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Substitution Implementation}

The substitution function is easily modified to work with environments rather than single bindings:

\begin{tinycode}
substitute :: Env -> Exp -> Exp
substitute env exp = subst exp where
  subst (Number i)      = Number i
  subst (Add a b)       = Add (subst a) (subst b)
  subst (Subtract a b)  = Subtract (subst a) (subst b)
  subst (Multiply a b)  = Multiply (subst a) (subst b)
  subst (Divide a b)    = Divide (subst a) (subst b)
  subst (Variable name) =
    case lookup name env of
      Just val -> Number val
      Nothing  -> Variable name
\end{tinycode}

Can run tests using this \href{https://harrisonwl.github.io/assets/courses/popl/fall2016/aopl/code/SubstituteTest.hs.htm}{code}.

\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Local Variables}
%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Local variables}

\begin{itemize}
\item All variables have been defined so far \emph{outside} the expression itself
\item Useful to allow variables to be defined \emph{within} an expression 

\pause
\item Most PLs support this with local variables; e.g., x and y in the following:
\begin{hcode}
let x = 3 in let y = x*2 in x + y
\end{hcode}

\pause
\item Variable declaration expression can be represented by adding another case to the definition of expressions: 
\begin{hcode}
data Exp = ...
         | Declare String Exp Exp
\end{hcode}
\end{itemize}

%\begin{codeblock}
%\begin{hcode}
%
%\end{hcode}
%\end{codeblock}

\end{frame}
%%%%%%%%%
%%%%%%%%%

\subsubsection{Scope}

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Scope}

\begin{block}{Scope of a Variable Declaration} is the portion of the code text where that declaration holds.
\end{block}

\begin{center}
\includegraphics[scale=0.75]{figures/ScopeExample.pdf}
\end{center}

\end{frame}
%%%%%%%%%
%%%%%%%%%

\subsection{Processing Declarations}

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Processing Declarations}

\noindent Substituting into Variable Declarations
\begin{hcode}
substitute1 (var, val) exp = subst exp
  ...
  subst (Declare x exp body)  = Declare x (subst exp) body'
    where body' = if x == var
                  then body
                  else subst body
\end{hcode}

\pause
\noindent Evaluating Variable Declarations using Substitution:
\begin{hcode}
evaluate (Declare x exp body) 
     = evaluate (substitute1 (x, evaluate exp) body)
\end{hcode}
\end{frame}
%%%%%%%%%
%%%%%%%%%



%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Undefined Variable Errors}

\begin{block}{New Kind of Error}
Attempting to evaluate an expression containing a variable that does not have a value. 
\end{block}

\noindent For example, this pseudocode contains undefined variables:
\begin{codeblock}
\begin{hcode}
x + 3
var x = 2; x * y
(var x = 3; x) * x
\end{hcode}
\end{codeblock}

\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Static vs Dynamic Properties}

\begin{block}{Static Property}
A {\bf static property} of a program can be determined by examining the text of the program but without executing or evaluating it.
\end{block}

\begin{block}{Dynamic Property}
A {\bf dynamic property} of a program can only be determined by evaluating the program.
\end{block}

\pause
\begin{itemize}
\item \emph{variable is undefined}: static property of the program: 
\begin{itemize}
\item whether it is undefined depends only on program text, not upon the particular data that the program is manipulating. 
\end{itemize}

\pause
\item \emph{divide by zero error} depends on particular data that the program is manipulating. 
\begin{itemize}
\item As a result, divide by zero is a dynamic error.
\end{itemize}

\end{itemize}

\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Static vs. Dynamic}
\begin{block}{Static Property}
A {\bf static property} of a program can be determined by examining the text of the program but without executing or evaluating it.
\end{block}

\begin{block}{Dynamic Property}
A {\bf dynamic property} of a program can only be determined by evaluating the program.
\end{block}

\begin{itemize}
\item Might be possible to identify, just from examining the text of a program, that it will always divide by zero. 

\item Alternatively, may be that the code containing an undefined variable is never executed at runtime. 

\item Thus, boundary between static and dynamic errors is not absolute. 
\end{itemize}

\end{frame}
%%%%%%%%%
%%%%%%%%%

\subsubsection{Summary}
%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Summary}

\begin{teenycode}
data Exp = Number     Int
         | Add        Exp Exp
            %$\ldots$%
         | Divide     Exp Exp
         | Variable   String
         | Declare    String Exp Exp

substitute1 (var, val) exp = subst exp where
  subst (Number i)      = Number i
  subst (Add a b)       = Add (subst a) (subst b)
            %$\ldots$%
  subst (Divide a b)    = Divide (subst a) (subst b)
  subst (Variable name) = if var == name
                          then Number val
                          else Variable name
  subst (Declare x exp body)  = Declare x (subst exp) body'
    where body' = if x == var
                  then body
                  else subst body

evaluate :: Exp -> Int
evaluate (Number i)       = i
evaluate (Add a b)        = evaluate a + evaluate b
            %$\ldots$%
evaluate (Divide a b)     = evaluate a `div` evaluate b
evaluate (Declare x exp body) = evaluate (substitute1 (x, evaluate exp) body)
\end{teenycode}

\end{frame}
%%%%%%%%%
%%%%%%%%%

\subsection{Evaluation using Environments}

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Evaluation using substitution}

\begin{columns}
\begin{column}{0.7\textwidth}
\begin{tabular}{ll}
\hline
Step & Result\\ 
\hline\hline \pause
initial expression 
&
\begin{teenycode}
var x = 2;
var y = x + 1;
var z = y + 2;
x * y * z
\end{teenycode} 
\\\hline \pause
eval bound expr. & {\footnotesize$\mathtt{2} \Rightarrow \mathtt{2}$}
\\\hline \pause
subst {\footnotesize$\mathtt{x}\mapsto\mathtt{2}$} 
&
\begin{teenycode}
var y = 2 + 1;
var z = y + 2;
2 * y * z
\end{teenycode}
\\\hline \pause
eval bound expr &
{\footnotesize$\mathtt{2 + 1 \Rightarrow 3}$}	
\\\hline \pause
subst {\footnotesize$\mathtt{y\mapsto 3}$} &
\begin{teenycode}
var z = 3 + 2;
2 * 3 * z
\end{teenycode}
\\\hline \pause
eval bound expr & {\footnotesize$\mathtt{3 + 2 \Rightarrow 5}$}
\\\hline \pause
subst. {\footnotesize$\mathtt{z\mapsto 5}$} & \begin{teenycode}
2 * 3 * 5
\end{teenycode}
\\\hline \pause
eval body & 	
\begin{teenycode}
2 * 3 * 5 %$\Rightarrow$% 30
\end{teenycode}
\end{tabular}
\end{column}
\end{columns}

\pause
\vfill
\noindent Correct, albeit not terribly efficient. Why?


\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Evaluating expressions in an environment}

\begin{tinycode}
evaluate :: Exp %\textbf{\textcolor{red}{-> Env}}% -> Int
evaluate (Number i) env     = i
evaluate (Add a b) env       
       = evaluate a env + evaluate b env
evaluate (Subtract a b) env  
       = evaluate a env - evaluate b env
evaluate (Multiply a b) env  
       = evaluate a env * evaluate b env
evaluate (Divide a b) env    
       = evaluate a env `div` evaluate b env
evaluate (Variable x) env    = fromJust (lookup x env)
evaluate (Declare x exp body) env = evaluate body newEnv
  where newEnv = (x, evaluate exp env) : env
  
fromJust :: Maybe a -> a
fromJust (Just a) = a
fromJust Nothing  = error "Doh!"
\end{tinycode}
\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Shorthand}

\begin{hcode}
var x = 2;
var y = x + 1;
var z = y + 2;
x * y * z
\end{hcode}

is shorthand for:

\begin{smallcode}
Declare "x" (Number 2)
 (Declare "y" (Add (Variable "x") (Number 1))
   (Declare "z" (Add (Variable "y") (Number 2))
     (Multiply (Variable "x") 
       (Multiply (Variable "y") 
                 (Variable "z")))))             
\end{smallcode}

\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Evaluating with Environments}

\begin{tabular}{ll}
Environment & Evaluation
\\\hline\hline \pause
$\emptyset$
&
\begin{teenycode}
var x = 2;
var y = x + 1;
var z = y + 2;
x * y * z
%\{{\it eval bound expr \texttt{2}}\}%
\end{teenycode}
\\ \hline \pause
$\emptyset$
&
\begin{teenycode}
%$\mathtt{2 \Rightarrow 2}$%
%\{ {\it add new binding} $\mathtt{x \mapsto 2}$\}%
\end{teenycode}
\\ \hline \pause
$\mathtt{x \mapsto 2}$
&
\begin{teenycode}
var y = x + 1;
var z = y + 2;
x * y * z
%\{ {\it eval bound expr} \texttt{x + 1} \}%
\end{teenycode}
\\ \hline \pause
$\mathtt{x \mapsto 2}$
&
\begin{teenycode}
%$\mathtt{x + 1 \Rightarrow 3}$%
%\{ {\it add new binding} $\mathtt{y \mapsto 3}$\}%
\end{teenycode}
\\ \hline \pause
$\mathtt{y \mapsto 3, x \mapsto 2}$
&
\begin{teenycode}
var z = y + 2;
x * y * z
%$\{ {\it eval~ bound ~expr~} \mathtt{y + 2} \}$%
\end{teenycode}
\\ \hline \pause
$\mathtt{y \mapsto 3, x \mapsto 2}$
&
\begin{teenycode}
%$\mathtt{ y + 2 \Rightarrow 5}$%
%$\{\mathtt{{\it add~new~binding~for}~ z;}$% 
 %{\it eval body of var decl }\}%
\end{teenycode}
\\ \hline \pause
$\mathtt{z \mapsto 5, y \mapsto 3, x \mapsto 2}$
&
\begin{teenycode}
%$\mathtt{x * y * z \Rightarrow 30}$%
\end{teenycode}
\begin{teenycode}
\end{teenycode}
\end{tabular}
\vfill

\noindent{\small * Text has an obvious typo.}
\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{``Shadowing''}

\begin{tabular}{ll}
Environment & Evaluation
\\\hline\hline \pause
$\emptyset$
&
\begin{teenycode}
var x = 9; var x = x * x; x + x
%$\{ \mbox{{\it eval bound expr}}~ \mathtt{9} \}$%
\end{teenycode}
\\\hline \pause
$\emptyset$
&
\begin{teenycode}
%$\mathtt{9 \Rightarrow 9}$%
%$\{ {\it add}~ \mathtt{x \mapsto 9},~ {\it eval ~body ~of ~var ~decl} \}$%
\end{teenycode}
\\\hline \pause
$\mathtt{x \mapsto 9}$
&
\begin{teenycode}
var x = x * x; x + x
%$\{ {\it eval~ bound~ expr}~ x * x \}$%
\end{teenycode}
\\\hline \pause
$\mathtt{x \mapsto 9}$
&
\begin{teenycode}
%$\{ {\it add}~ \mathtt{x \mapsto 81}, eval~ body~ of~ var~ decl \}$%
\end{teenycode}
\\\hline \pause
$\mathtt{x \mapsto 81, x \mapsto 9}$
&
\begin{teenycode}
%$\mathtt{x + x \Rightarrow 162}$%
\end{teenycode}
\end{tabular}
\pause
\vfill
\begin{itemize}
\item Final environment contains two bindings for {\tt x}, but the leftmost one is used? Why?
\end{itemize}

\end{frame}
%%%%%%%%%
%%%%%%%%%

\section{Booleans \& Conditionals}

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Extension to Booleans and Conditionals}
\framesubtitle{Full code 
\href{https://harrisonwl.github.io/assets/courses/popl/fall2016/aopl/code/IntBool.hs.htm}{here}}


\begin{itemize}
\item Extend values:
\begin{hcode}
data Value  =  IntV  Int
            |  BoolV Bool
 deriving (Eq)
\end{hcode}
\item Extend abstract syntax:
\begin{hcode}
data BinaryOp = Add | Sub | Mul | Div | And | Or
              | GT | LT | LE | GE | EQ
                       deriving (Show, Eq)

data UnaryOp = Neg | Not deriving (Show, Eq)

data Exp  = Literal   Value
          | Unary     UnaryOp Exp
          | Binary    BinaryOp Exp Exp
          | If        Exp Exp Exp
          | Variable  String
          | Declare   String Exp Exp
\end{hcode}
\end{itemize}

\end{frame}
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Helper Functions}
\framesubtitle{\textcolor{red}{What are their types?}}

\begin{hcode}
unary Not (BoolV b) = BoolV (not b)
unary Neg (IntV i)  = IntV (-i)

binary Add (IntV a)  (IntV b)  = IntV (a + b)
binary Sub (IntV a)  (IntV b)  = IntV (a - b)
binary Mul (IntV a)  (IntV b)  = IntV (a * b)
binary Div (IntV a)  (IntV b)  = IntV (a `div` b)
binary And (BoolV a) (BoolV b) = BoolV (a && b)
binary Or  (BoolV a) (BoolV b) = BoolV (a || b)
binary LT  (IntV a)  (IntV b)  = BoolV (a < b)
binary LE  (IntV a)  (IntV b)  = BoolV (a <= b)
binary GE  (IntV a)  (IntV b)  = BoolV (a >= b)
binary GT  (IntV a)  (IntV b)  = BoolV (a > b)
binary EQ  a         b         = BoolV (a == b)
\end{hcode}

\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Defining Conditional}

\begin{hcode}
evaluate (If a b c) env =
  let BoolV test = evaluate a env in
    if test then evaluate b env
            else evaluate c env
\end{hcode}

\vfill
\pause
\noindent What happens if {\tt a} doesn't evaluate to a {\tt BoolV}?
\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
\end{document}
