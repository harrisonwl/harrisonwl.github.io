\documentclass{beamer}

\usepackage{listings,color}

\input{globals}
%\usetheme{Singapore}
%\useoutertheme{myinfolines}
\usecolortheme{rose}

%\usecolortheme{seahorse}
\useinnertheme[shadow]{rounded} 
\setbeamertemplate{navigation symbols}{}

\usepackage[all]{xy}
\usepackage{xmpmulti}
%\usepackage{pdfpages}

\newenvironment{codeblock}[1][.8]{%
\begin{columns}
\begin{column}{#1\linewidth}
\begin{exampleblock}{}}{%
\end{exampleblock}
\end{column}
\end{columns}} 

\newenvironment{execblock}[1][.8]{%
\begin{columns}
\begin{column}{#1\linewidth}
\begin{block}{}}{%
\end{block}
\end{column}
\end{columns}} 

\def\slideskip{\vskip 0.1in}
\def\frameskip{\vskip 0.1in}


%\begin{frame}
%\begin{figure}[t]
%\includegraphics[width=1\textwidth]{example1.png}
%\end{figure}
%\end{frame}

\title[CS4450]{CS4450/7450\\Chapter 2: Starting Out}
\subtitle{Principles of Programming Languages}
\author[Bill Harrison]{Dr. William Harrison}
\institute{University of Missouri}
%\date{August 31, 2011}

\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
\frametitle{GHCi is basically a fancy calculator}

\begin{codeblock}
\begin{hcode}
$ ghci
GHCi, version 7.10.3: http://www.haskell.org/ghc/  :? for help
Prelude> 4 + 2
6
Prelude> not (True && True)
False
Prelude> max 5 4
5
\end{hcode}
\end{codeblock}
\end{frame}

\begin{frame}[fragile]
\frametitle{Type errors are your friends}
\begin{codeblock}
\begin{hcode}
Prelude> 99 + "Hey"
<interactive>:5:4:
    No instance for (Num [Char]) arising from a use of `+`
    In the expression: 99 + "Hey"
    In an equation for `it`: it = 99 + "Hey"
Prelude> 
\end{hcode}
\end{codeblock}

\end{frame}

\begin{frame}[fragile]
\frametitle{GHCi Commands}
\framesubtitle{Some Pragmatics}
\begin{itemize}
\item \verb+:l+ or \verb+:load+ --- load a file or module

\item \verb+:t:+ or \verb+:type+ --- give the type of an expression

\item \verb+:i+ or \verb+:info+ --- produce information about a definition

\item \verb+:q+ or \verb+:quit+ --- quit, derp.

\end{itemize}

\pause
\begin{codeblock}
\begin{hcode}
Prelude> :t not
not :: Bool -> Bool
Prelude> :i not
not :: Bool -> Bool 	
        -- Defined in `GHC.Classes`
Prelude> 
\end{hcode}
\end{codeblock}

\end{frame}


\begin{frame}[fragile]
\frametitle{``Baby's First Program''}

Entered in a file \verb+Chap2.hs+:
\begin{codeblock}
\begin{hcode}
module Chap2 where

doubleMe x = x + x  
\end{hcode}
\end{codeblock}

\end{frame}

\begin{frame}[fragile]
\frametitle{``Baby's First Program'', cont'd}
\begin{codeblock}
\begin{hcode}
$ ghci
GHCi, version 7.10.3: http://www.haskell.org/ghc/  :? for help
Prelude> :l Chap2.hs
[1 of 1] Compiling Chap2            ( Chap2.hs, interpreted )
Ok, modules loaded: Chap2.
*Chap2> doubleMe 9
18
*Chap2> doubleMe 3.14
6.28
*Chap2> :t doubleMe
\end{hcode}
\end{codeblock}
\pause
\begin{codeblock}
\begin{hcode}
doubleMe :: Num a => a -> a
*Chap2> 
\end{hcode}
\end{codeblock}
\end{frame}


\begin{frame}[fragile]
\frametitle{Lists, an Introduction to}
\begin{codeblock}
\begin{hcode}
Prelude> let lostNumbers = [4,8,15,16,23,42] 
Prelude> lostNumbers
[4,8,15,16,23,42]

Prelude> 99 : lostNumbers
[99,4,8,15,16,23,42]

Prelude> [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]

Prelude> "hello" ++ " " ++ "world"
"hello world"

Prelude> ['w','0'] ++ ['0','t']
"w00t"
\end{hcode}
\end{codeblock}
\end{frame}


\begin{frame}[fragile]
\frametitle{Some Facts about Lists}

\begin{itemize}

\item \verb+[]+, \verb+[[]]+ and \verb+[[],[],[]]+ are all different things. What are their types? Can check that with GHCi.

\pause

\item Lists are \emph{uniform} in Haskell. E.g., \verb+[1,2,3]+ is legal and \verb+[1,2,'c']+ is not.

\pause 

\item The \verb+data+ declaration for lists in Haskell is:
\begin{hcode}
data [a] = [] | a : [a]
\end{hcode}


\end{itemize}


\end{frame}

\begin{frame}[fragile]
\frametitle{Basic Function on Lists}

\verb+head+ takes a list and returns its head. The head of a list is  its first element (if it exists).
\begin{codeblock}
\begin{hcode}
ghci> head [5,4,3,2,1]  
5
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+head+?

\item How do we write \verb+head+ in Haskell?

\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Basic Function on Lists}

\verb+tail+ takes a list and returns its tail. In other words, it chops off a list's head.

\begin{codeblock}
\begin{hcode}
ghci> tail [5,4,3,2,1]  
[4,3,2,1]  
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+tail+?

\item How do we write \verb+tail+ in Haskell?

\end{itemize}

\end{frame}

\begin{frame}[fragile]
\frametitle{Basic Function on Lists}

If you want to get an element out of a list by index, use \verb+!!+. The indices start at 0.

\begin{codeblock}
\begin{hcode}
ghci> "Steve Buscemi" !! 6  
'B'  
ghci> [9.4,33.2,96.2,11.2,23.25] !! 1  
33.2  
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+!!+?

\item How do we write \verb+!!+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{More Basic Functions on Lists}

\verb+last+ takes a list and returns its last element.

\begin{codeblock}
\begin{hcode}
ghci> last [5,4,3,2,1]  
1   
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+last+?

\item How do we write \verb+last+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{More Basic Functions on Lists}


\verb+init+ takes a list and returns everything except its last element.

\begin{codeblock}
\begin{hcode}
ghci> init [5,4,3,2,1]  
[5,4,3,2]   
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+init+?

\item How do we write \verb+init+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{More Basic Functions on Lists}


\verb+length+ takes a list and returns its length, obviously.

\begin{codeblock}
\begin{hcode}
ghci> length [5,4,3,2,1]  
5
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+length+?

\item How do we write \verb+length+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{More Basic Functions on Lists}


\verb+null+ checks if a list is empty. If it is, it returns \verb+True+, otherwise it returns \verb+False+. Use this function instead of \verb+xs == []+ (if you have a list called \verb+xs+).

\begin{codeblock}
\begin{hcode}
ghci> null [1,2,3]  
False  
ghci> null []  
True
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+null+?

\item How do we write \verb+null+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{More Basic Functions on Lists}

\verb+reverse+ reverses a list.

\begin{codeblock}
\begin{hcode}
ghci> reverse [5,4,3,2,1]  
[1,2,3,4,5] 
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+reverse+?

\item How do we write \verb+reverse+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{More Basic Functions on Lists}

\verb+take+ takes number and a list. It extracts that many elements from the beginning of the list. 

\begin{codeblock}
\begin{hcode}
ghci> take 3 [5,4,3,2,1]  
[5,4,3]  
ghci> take 1 [3,9,3]  
[3]  
ghci> take 5 [1,2]  
[1,2]  
ghci> take 0 [6,6,6]  
[]  
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+take+?

\item How do we write \verb+take+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{More Basic Functions on Lists}

\verb+drop+ works in a similar way, only it drops the number of elements from the beginning of a list.

\begin{codeblock}
\begin{hcode}
ghci> drop 3 [8,4,2,1,5,6]  
[1,5,6]  
ghci> drop 0 [1,2,3,4]  
[1,2,3,4]  
ghci> drop 100 [1,2,3,4]  
[] 
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+drop+?

\item How do we write \verb+drop+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{More Basic Functions on Lists}

\verb+maximum+ takes a list of stuff that can be put in some kind of order and returns the biggest element.

\begin{codeblock}
\begin{hcode}
ghci> maximum [1,9,2,3,4]  
9   
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+maximum+?

\item How do we write \verb+maximum+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{More Basic Functions on Lists}


\verb+sum+ takes a list of numbers and returns their sum.

\begin{codeblock}
\begin{hcode}
ghci> sum [5,2,1,6,3,2,5,7]  
31  
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+sum+?

\item How do we write \verb+sum+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{More Basic Functions on Lists}

\verb+elem+ takes a thing and a list of things and tells us if that thing is an element of the list. It's usually called as an infix function because it's easier to read that way.

\begin{codeblock}
\begin{hcode}
ghci> 4 `elem` [3,4,5,6]  
True  
ghci> 10 `elem` [3,4,5,6]  
False 
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+elem+?

\item How do we write \verb+elem+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Texas (?!) Ranges}


\begin{codeblock}
\begin{hcode}
ghci> [1..20]  
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]  

ghci> ['a'..'z']  
"abcdefghijklmnopqrstuvwxyz"  

ghci> ['K'..'Z']  
"KLMNOPQRSTUVWXYZ"  
\end{hcode}
\end{codeblock}


\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Infinite Lists}

\verb+repeat+ takes an element and produces an infinite list of just that element. It's like cycling a list with only one element.

\begin{codeblock}
\begin{hcode}
ghci> take 10 (repeat 5)  
[5,5,5,5,5,5,5,5,5,5] 
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+repeat+?

\item How do we write \verb+repeat+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Infinite Lists}

\verb+cycle+ takes a list and cycles it into an infinite list. If you just try to display the result, it will go on forever so you have to slice it off somewhere.

\begin{codeblock}
\begin{hcode}
ghci> take 10 (cycle [1,2,3])  
[1,2,3,1,2,3,1,2,3,1]  
ghci> take 12 (cycle "LOL ")  
"LOL LOL LOL " 
\end{hcode}
\end{codeblock}

\begin{itemize}

\item What is the type of \verb+cycle+?

\item How do we write \verb+cycle+ in Haskell?

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Set Comprehensions}

In the lingo of Mathematics, the following definition is a \emph{set comprehension}:
\begin{codeblock}
\[
S = \{ 2 \ast x ~|~ x \in Nat,~ x \leq 10 \}
\]
\end{codeblock}

\begin{itemize}

\item \(S = \{ 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20 \}\).

\pause

\item There is a similar notion in Haskell known as a \emph{list comprehension}. 
\begin{codeblock}
\begin{hcode}
ghci> [2*x | x <- [1..10]]  
[2,4,6,8,10,12,14,16,18,20] 
\end{hcode}
\end{codeblock}

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{List Comprehension Examples}

\begin{itemize}

\item Multiple Generators:
\begin{hcode}
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]  
[16,20,22,40,50,55,80,100,110]   
\end{hcode}

\pause
\item Adding constraints:
\begin{tinycode}
ghci> [ x*y | x <- [2,5,10], y <- [8,10,11], %{\color{red}{x*y > 50}}%]  
[55,80,100,110]    
\end{tinycode}

\pause
\item As part of functions:
\begin{tinycode}
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]   
\end{tinycode}
Testing it out:
\begin{hcode}
ghci> removeNonUppercase "Hahaha! Ahahaha!"  
"HA"  
ghci> removeNonUppercase "IdontLIKEFROGS"  
"ILIKEFROGS"   
\end{hcode}

\end{itemize}

\end{frame}

%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Tuples}

%
%\begin{codeblock}
%\begin{hcode}
%\end{hcode}
%\end{codeblock}

\begin{itemize}

\item These are built-in type constructors for ordered pairs, ordered triples, etc. E.g., \verb+("Wow",'a')+ is an ordered pair.
\pause

\item Tuple types are written in the same style as tuple expressions:
\begin{hcode}
ghci> :t ("Wow",'a')
("Wow",'a') :: %{\color{red}{([Char], Char)}}%
\end{hcode}
\pause
\item There are Prelude-defined functions for \emph{pairs}:
\begin{hcode}
:t fst
fst :: (a, b) -> a
ghci> :t snd
snd :: (a, b) -> b
ghci> fst ("Wow",'a')
"Wow"
ghci> snd ("Wow",'a')
'a'
\end{hcode}


\end{itemize}

\end{frame}


%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Zippers}

\begin{codeblock}
\begin{hcode}
ghci> zip [1,2,3,4,5] [5,5,5,5,5]  
[(1,5),(2,5),(3,5),(4,5),(5,5)]  

ghci> zip [1 .. 5] ["one", "two", "three", "four", "five"]  
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")] 

ghci> zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]  
[(5,"im"),(3,"a"),(2,"turtle")] 
\end{hcode}
\end{codeblock}

\begin{itemize}

\item Notice the input lists need not be of the same length.

\item What is the type of \verb+zip+?

\item How do we write \verb+zip+ in Haskell?

\end{itemize}

\end{frame}

\end{document}
