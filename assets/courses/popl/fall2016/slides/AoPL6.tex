\documentclass[xcolor=pdftex,dvipsnames,table]{beamer}

\usepackage{listings}
\usepackage{haskell}
\input{globals}
\usetheme{Berlin}
%\usetheme{Boadilla}
%\usetheme{Singapore}
%\usetheme{Berkeley}
\useoutertheme{infolines}
\usecolortheme{lily}
%\usepackage{beamerthemesplit}
\setbeamertemplate{footline}[page number]{}

\setbeamertemplate{footline}[text line]{}
%\usecolortheme{seahorse}
\useinnertheme[shadow]{rounded} 
\setbeamertemplate{navigation symbols}{}
%\usepackage[absolute,overlay]{textpos} 

%\usepackage[all]{xy}
%\usepackage{xmpmulti}

%\usepackage{pdfpages}
\AtBeginSection[]
{
  \begin{frame}<beamer>
    \frametitle{Outline for section \thesection}
    \tableofcontents[currentsection]
  \end{frame}
}


\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=red,
}
 
\urlstyle{same}

\newenvironment{codeblock}[1][.8]{%
\begin{columns}
\begin{column}{#1\linewidth}
\begin{exampleblock}{}}{%
\end{exampleblock}
\end{column}
\end{columns}} 

\newenvironment{execblock}[1][.8]{%
\begin{columns}
\begin{column}{#1\linewidth}
\begin{block}{}}{%
\end{block}
\end{column}
\end{columns}} 

\def\slideskip{\vskip 0.1in}
\def\frameskip{\vskip 0.1in}


%\begin{frame}
%\begin{figure}[t]
%\includegraphics[width=1\textwidth]{example1.png}
%\end{figure}
%\end{frame}

\title[CS4450]{CS4450/7450\\AoPL, Chapter 6: Computational Strategies}
\subtitle{Principles of Programming Languages}
\author[Bill Harrison]{Dr. William Harrison}
\institute{University of Missouri}
%\date{August 31, 2011}

\begin{document}

\frame{\titlepage}

%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

\begin{frame}[fragile]
\frametitle{Announcements}

\begin{itemize}

\item We're continuing with William Cook's online textbook, \emph{Anatomy of Programming Languages}. It is available
\href{https://www.cs.utexas.edu/~wcook/anatomy/}{here}. We're in Chapter 6.

\end{itemize}

\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Error Checking}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mutable State}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Mutable State}

\begin{block}{Mutable State}
Mutable state means that the state of a program changes or mutates: that a variable can be assigned a new value or a part of a data structure can be modified.
\end{block}

\vfill

Ex: The values of {\tt x} and {\tt i} change over time:
\begin{hcode}
x = 1;
for (i = 2; i <= 5; i = i + 1) {
  x = x * i;
}
\end{hcode}


\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Addresses}

\begin{block}{Addresses}
An address identifies a mutable container that stores a single value, but whose contents can change over time. Addresses are sometimes called locations.
\end{block}

\vfill

\pause

\begin{tabular}{l|l}
Operation & Meaning
\\
\hline\hline
\verb+mutable e+ & Creates a mutable cell with initial value given by \verb+e+
\\
\verb+@e+	& Accesses contents stored at address \verb+e+
\\
\verb+a = e+ & Updates contents at address \verb+a+ to be value of expression \verb+e+
\end{tabular}

\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Example}

\begin{hcode}
x = mutable 1;
for (i = mutable 2; @i <= 5; i = @i + 1) {
  x = @x * @i;
}
\end{hcode}

\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{New Values and Expressions}

\begin{hcode}
data Value = IntV  Int
           | BoolV Bool
           | ClosureV String Exp Env
           | AddressV Int        -- new
  deriving (Eq, Show)

type Memory = [Value]
\end{hcode}

\pause

\begin{hcode}
data Exp = ...
         | Mutable   Exp        -- mutable e
         | Access    Exp        -- @a
         | Assign    Exp Exp    -- a = e
\end{hcode}         

\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Illustrating Memory Operations}

\begin{tabular}{l|l}
Step&	Memory\\
\hline\hline
start&	[]
\\\pause
\verb+x = mutable 1;+	& [1] \pause
\\
\verb+i = mutable 2;+&	[1,2]\pause
\\
\verb+x = @x * @i;+	&[2,2]\pause
\\
\verb|i = @i + 1;|	& [2,3]\pause
\\
\verb+x = @x * @i;+&	[6,3]
\\
\verb|i = @i + 1;|&	[6,4]
\\
\verb+x = @x * @i;+&	[24,4]
\\
\verb|i = @i + 1;|	&[24,5]
\\
\verb+x = @x * @i;+&	[120,5]
\\
\verb|i = @i + 1;|	&[120,6]
\end{tabular}

\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

\subsection{Pure Functional Operations on Memory}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Operations on Memory}

\noindent Accessing Memory:
\begin{hcode}
access i mem = mem !! i
\end{hcode}

\vfill\pause

\noindent Updating Memory:
\begin{hcode}
update :: Int -> Value -> Memory -> Memory
update addr val mem =
  let (before, _ : after) = splitAt addr mem in
    before ++ [val] ++ after
\end{hcode}
\vfill

\pause
\begin{hcode}
ghci> :t splitAt
   splitAt :: Int -> [a] -> ([a], [a])
ghci> splitAt 3 "abcdefg"
   ("abc","defg")
ghci> splitAt 0 "abcdefg"
   ("","abcdefg")
\end{hcode}

\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Whither {\texttt{evaluate}}?}

\begin{itemize}
\item Currently:
\begin{hcode}
    evaluate :: Exp -> Env -> Value
\end{hcode}

\pause
\item Defn. A {\bf stateful computation} is a function that takes an input state and returns a value and an output state.


\pause
\item Now a stateful computation:
\begin{hcode}
    evaluate :: Exp -> Env -> %\textcolor{red}{Memory -> (Value,Memory)}%
\end{hcode}


\pause
\item Generalizing:
\begin{hcode}
    type Stateful a = Memory -> (a,Memory)
    evaluate :: Exp -> Env -> Memory -> Stateful Value
\end{hcode}


\end{itemize}

\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Evaluation Rules}

\begin{hcode}
evaluate (Mutable e) env mem = 
   let
      (ev, mem') = evaluate e env mem
   in 
      (AddressV (length mem'), mem' ++ [ev])
\end{hcode}

\pause

\begin{hcode}
evaluate (Access a) env mem =
  let 
     (AddressV i, mem') = evaluate a env mem 
  in
     (access i mem', mem')
\end{hcode}


\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Evaluation Rules (cont'd)}

\begin{hcode}
evaluate (Assign a e) env mem =
  let 
     (AddressV i, mem') = evaluate a env mem
  in  
     let 
        (ev, mem'') = evaluate e env mem' 
     in
        (ev, update i ev mem'')
\end{hcode}

\begin{hcode}
evaluate (Binary op a b) env mem =
  let 
     (av, mem') = evaluate a env mem 
  in
     let 
        (bv, mem'') = evaluate b env mem' 
     in
        (binary op av bv, mem'')
\end{hcode}

\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%

%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
\begin{frame}[fragile]
\frametitle{A pattern is forming...}

\begin{itemize}
\item Recall:
\begin{hcode}
evaluate (Mutable e) env mem = 
   let (ev, mem') = evaluate e env mem
   in  (AddressV (length mem'), mem' ++ [ev])
\end{hcode}

\pause

\item The pattern:
\begin{hcode}
 \ mem -> 
   let
      (val, mem') = %\textcolor{red}{{\it first-part}}% mem
   in 
      %\textcolor{red}{{\it next-part}}% val mem'
\end{hcode}

\pause

\item Generalizing as a higher-order function:
\begin{hcode}
(>>=) :: Stateful a -> (a -> Stateful b) -> Stateful b
%\textcolor{red}{{\it first-part}}% >>= %\textcolor{red}{{\it next-part}}% = 
 \ mem ->
   let
      (val, mem') = %\textcolor{red}{{\it first-part}}% mem
   in 
      %\textcolor{red}{{\it next-part}}% val mem'
\end{hcode}
\end{itemize}

\end{frame}
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%
%%%%%%%%%



\end{document}