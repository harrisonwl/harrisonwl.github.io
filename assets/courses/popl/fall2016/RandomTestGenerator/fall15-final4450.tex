\documentclass[12pt]{article}

\usepackage{haskell}
\usepackage{enumerate}
\usepackage{multicol}
\setlength{\topmargin}{-0.5in}
%\usepackage[yyyymmdd]{datetime}
\setlength{\textheight}{9.0in}
\setlength{\textwidth}{7.5in}
\setlength{\oddsidemargin}{-0.5in}
%\setlength{\evensidemargin}{-0.1in}
\setlength{\parindent}{0mm}
\setlength{\parskip}{0.1in}
%\renewcommand{\date}{Dec. 17, 2014}
\newcommand{\forget}[1]{}
% new itemize environment with itemsep parameter
\newenvironment{myitemize}[1][0]
  { \begin{itemize}
    % set spacing between items
    \addtolength{\itemsep}{#1\baselineskip}
    % set spacing between lines
    \addtolength{\baselineskip}{#1\baselineskip} }
  { \end{itemize} }

\newenvironment{myenumerate}[1][0]
  { \begin{enumerate}
    % set spacing between items
    \addtolength{\itemsep}{#1\baselineskip}
    % set spacing between lines
    \addtolength{\baselineskip}{#1\baselineskip} }
  { \end{enumerate} }


\newcommand{\ra}{\ensuremath{\rightarrow}}
  
    
\pagestyle{empty}
%\pagenumbering{nopagenumbering}
\usepackage{datetime}
\newdate{date}{18}{12}{2015}
\usdate
%\thispagestyle{empty}
\begin{document}
 
\title{\vspace{10ex}CS4450/7450 Final\\Fall 2015\\ \date{\displaydate{date}}}


\maketitle
{\Large
\begin{flushleft}
{\bf Name:}\\
{\bf Student Number:}
\end{flushleft}
}
\vfill

\thispagestyle{empty}


{\large
\begin{center}
\begin{minipage}{4.5in}
\begin{itemize}
\item This is a closed book, closed note exam.
\item You may not use a calculator or similar device.
\item There are 47 problems, worth 100 points total.
\item Unless otherwise noted, each question is worth 2 points.
\end{itemize}
\end{minipage}
\end{center}
}

\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
{\bf Directions.} Indicate which of the following statements are true or false by marking {\bf True} or {\bf False} 
in the corresponding answer location on your answer sheet.
\begin{enumerate}


%\begin{enumerate}
\vspace{5ex}
\item {\bf True} or {\bf False}: ``\emph{Haskell has higher order functions.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Haskell is statically typed.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Haskell terms are dynamically typed.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Static typing increases execution time.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{In Haskell, {\tt ((f x) y) == (f x y).}}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{The {\tt length} function can be defined as {\tt length = map f} for some f.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{The {\tt Maybe} type expresses computations that can fail.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Correctly typed Haskell programs never crash.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Haskell functions can be declared with different numbers of arguments.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Side effects in programs are things that are unintended by programmers.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{The {\tt type} reserved word in Haskell produces a new type.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Data constructors in Haskell are actually functions.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Global variables can be declared in Haskell using a let binding}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Haskell Strings are a kind of array, like in C.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Free variables are variables bound in some larger lexical scope.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{The {\tt map} function is a kind of fold.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Partial application is always performed by giving a function another function as an argument.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Haskell data types support inheritance.}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{(+ 2) has the type {\tt :: Num a => a}}''
\vspace{1ex}

\item {\bf True} or {\bf False}: ``\emph{Haskell lists can be of infinite length.}''
\vspace{1ex}
%\end{enumerate}


%Show class, abstract syntax, side effect.
%
%Representing syntax, e.g., express "while True do Skip" in this AST
%
%a) What is a closure and what is it used for?
%
%b) What is referential transparency?
%
%
%c) Explain the difference between the formal and actual parameters of a procedure.
%


\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\item[] {\bf Directions.}
For each of the Haskell declarations  below on the left,
its type occurs on the right below. Select the matching type from the answer bank on the right.
Each declaration has a matching type, but not every type in the answer bank has a declaration (i.e.
{\bf you will not use every answer} in the answer bank). Mark your answers on the answer sheet.

\vspace{4ex}

\begin{minipage}{2.5in}
%\begin{enumerate}
\item \begin{verbatim} f (x, y) = (y, x) \end{verbatim}

\item \begin{verbatim} f a = "buzz" \end{verbatim}

\item \begin{verbatim} f g a b = g a b \end{verbatim}

\item \begin{verbatim} f g h a = (g a, f a) \end{verbatim}

\item \begin{verbatim}
f x = show x
\end{verbatim}

\item \begin{verbatim}
f g a b = g a == g b
\end{verbatim}

\item \begin{verbatim} 
f x = case x of 
       Nothing -> 0
       Just n  -> n
\end{verbatim}

\item \begin{verbatim}
f x = case x of
       Nothing -> undefined
       Just n  -> n 
\end{verbatim}

\item \begin{verbatim}
f = [(Just "zed",Nothing),
     (Just "fox",Just 1)]
\end{verbatim}

\item \begin{verbatim}
f = [(Nothing,Nothing)]
\end{verbatim}
%\end{enumerate}
\end{minipage}
\hspace{1.2in}
\begin{minipage}{2in}
\begin{enumerate}[(a)]
\item \begin{verbatim}
:: (z,y) -> (y,z)
\end{verbatim}

\item \begin{verbatim}
:: [(Maybe a, Maybe a)]
\end{verbatim}

\item \begin{verbatim}
:: (y -> z -> a) 
      -> y -> z -> a
\end{verbatim}


\item \begin{verbatim}
:: Show a => a -> String
\end{verbatim}

\item \begin{verbatim}
:: (a -> Bool) -> a -> a -> Bool
\end{verbatim}

\item \begin{verbatim}
:: a -> String
\end{verbatim}
\item \begin{verbatim}
:: Num a => Maybe a -> a
\end{verbatim}

\item \begin{verbatim}
:: Maybe zed -> zed
\end{verbatim}

\item \begin{verbatim}
:: (Bool -> Bool -> Bool) -> 
       Bool -> Bool -> Bool
\end{verbatim}

\item \begin{verbatim}
:: (a -> b) -> (a -> b) 
      -> a -> (b,b)
\end{verbatim}
\item \begin{verbatim}
:: Num a => [(Maybe String,Maybe a)]
\end{verbatim}

\item \begin{verbatim}
:: String
\end{verbatim}

\item \begin{verbatim}
:: Show a => (Maybe a, Maybe a)
\end{verbatim}

\item \begin{verbatim}
:: Ord b  => [(Maybe b, Maybe b)]
\end{verbatim}


\end{enumerate}
\end{minipage}


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

{\bf Directions. (10 points total, 1 point each)} For each of the Haskell declarations \verb+e0-e9+ below on the left, its type
occurs on the right below. Draw a line from the declaration to its type on the right.
\begin{verbatim}
map     :: (a -> b) -> [a] -> [b]
id      :: a -> a
foldr   :: (a -> b -> b) -> b -> [a] -> b
(.)     :: (a -> b) -> (c -> a) -> c -> b
reverse :: [a] -> [a]
curry   :: ((a,b) -> c) -> (a -> b -> c)
uncurry :: (a -> b -> c) -> (a,b) -> c
concat  :: [[a]] -> [a]
take    :: Int -> [a] -> [a]
\end{verbatim}

\begin{minipage}{2.5in}
\item \verb+e0 = map reverse+
\vspace{3ex}
\item \verb+e1 = map (.)+
\vspace{3ex}
\item \verb+e2 = (.) map+
\vspace{3ex}
\item \verb+e3 = map . foldr+
\vspace{3ex}
\item \verb+e4 = foldr id+
\vspace{3ex}
\item \verb+e5 = foldr . id+
\vspace{3ex}
\item \verb+e6 = map . take+
\vspace{3ex}
\item \verb+e7 = curry . uncurry+
\vspace{3ex}
\item \verb+e8 = uncurry . curry+
\vspace{3ex}
\item \verb+e9 = map concat+
\end{minipage}
\hspace{1in}
\begin{minipage}{2in}
%\begin{enumerate}[(a)]
%\item 1
%\item 2
%\item 3
%\end{enumerate}
\begin{verbatim}
:: (a -> b -> b) -> b -> [a] -> b


:: (a -> b -> b) -> [b] -> [[a] -> b]


:: a -> [a -> a] -> a


:: (a -> b -> c) -> a -> b -> c


:: [[[a]]] -> [[a]]


:: Int -> [[a]] -> [[a]]


:: [[a]] -> [[a]]


:: [a -> b] -> [(c -> a) -> c -> b]


:: (a -> b -> c) -> a -> [b] -> [c]


:: ((a,b) -> c) -> (a,b) -> c
\end{verbatim}
\end{minipage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\item[] {\bf Directions.} The following questions concern the translation from {\tt Prop} to {\tt NAND}.

\begin{minipage}[t]{2.7in}
{\footnotesize
\begin{verbatim}
data Prop = Atom String
          | Not Prop
          | Imply Prop Prop
          | Or Prop Prop
          | And Prop Prop
          | Iff Prop Prop
          deriving Show

data NAND = Vbl String 
          | NAND :| NAND 
             deriving Show
\end{verbatim}
}
\end{minipage}
\begin{minipage}[t]{2in}
{\footnotesize
\begin{verbatim}
trans :: Prop -> NAND
trans (Atom v)      = Vbl v
trans (Not p)       = trans p :| trans p
trans (Or p1 p2)    = (p1' :| p1') :| (p2' :| p2')
  where p1' = trans p1
        p2' = trans p2
trans (And p1 p2)   = (p1' :| p2') :| (p1' :| p2')
  where p1' = trans p1
        p2' = trans p2
trans (Imply p1 p2) = p1' :| (p2' :| p2')
  where p1' = trans p1
        p2' = trans p2
trans (Iff p1 p2)   = trans (And (Imply p1 p2) (Imply p2 p1))
\end{verbatim}
}
\end{minipage}

\item For which \verb+q :: Prop+ does \verb+(trans q)+ produce:
\begin{verbatim}
(Vbl "p" :| Vbl "p") :| ((Vbl "p" :| Vbl "p") :| (Vbl "p" :| Vbl "p"))
\end{verbatim}

\begin{enumerate}[(a)]
\item \verb+q+ is \verb+(Imply (Not (Atom "p")) (Atom "p"))+
\item \verb+q+ is \verb+(Not (And (Atom "p") (Not (Atom "p"))))+
\item \verb+q+ is \verb+(Or (Atom "p") (Not (Atom "p")))+
\item (b) and (c)
\item None of the above.
\end{enumerate}

\item For which \verb+q :: Prop+ does \verb+(trans q)+ produce:
{\scriptsize\begin{verbatim}
(Vbl "p" :| ((Vbl "p" :| Vbl "p") :| (Vbl "p" :| Vbl "p"))) :| (Vbl "p" :| ((Vbl "p" :| Vbl "p") :| (Vbl "p" :| Vbl "p")))
\end{verbatim}}
\begin{enumerate}[(a)]
\item \verb+q+ is \verb+(Or (Atom "p") (And (Atom "p") (Atom "p")))+
\item \verb+q+ is \verb+(Imply (Atom "p") (Or (Atom "p") (Atom "p")))+
\item \verb+q+ is \verb+(And (Atom "p") (And (Atom "p") (Atom "p")))+
\item \verb+q+ is \verb+(Or (Atom "p") (Or (Atom "p") (Atom "p")))+
\item None of the above.
\end{enumerate}

%\item  (4 points). Which of the following definitions of \verb+(Iff p1 p2)+ produces the same output?
%\begin{verbatim}
%trans (Iff p1 p2)   = ____
%  where p1' = trans p1
%        p2' = trans p2
%\end{verbatim}
%\begin{enumerate}[(a)]
%\item {\scriptsize\begin{verbatim}(p2' :| (p1' :| p1')) :| (p2' :| (p1' :| p1'))\end{verbatim}}
%
%\item {\scriptsize\begin{verbatim}((p1' :| (p2' :| p2')) :| (p2' :| (p1' :| p1'))) :| ((p1' :| (p2' :| p2')) :| (p2' :| (p1' :| p1')))\end{verbatim}}
%
%\item {\scriptsize\begin{verbatim}((p2' :| (p1' :| p1')) :| (p1' :| (p2' :| p2'))) :| ((p2' :| (p1' :| p1')) :| (p1' :| (p2' :| p2')))
%\end{verbatim}}       
%
%\item {\scriptsize\verb+(p1' :| (p2' :| p2')) :| (p1' :| (p2' :| p2'))+}
%
%\item \verb+None of the above.+
%\end{enumerate}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

{\bf Directions.} Consider the following context-free grammar for \<Exp\>:
\begin{haskell}
Exp &::=&\relax Identifer | ( {\mathbf{lambda}} Identifier Exp ) | ( Exp Exp )
\end{haskell}
An \<Identifier\> can be any non-empty string from \<\{\mathbf{a},\ldots,\mathbf{z}\}\>.

\item Which of the following are {\bf NOT} in the language of \<Exp\>?
\begin{enumerate}[(a)]
\item \<( {\mathbf{lambda}} )\>
\item \<( {\mathbf{lambda}} {\mathbf{lambda}} )\>
\item \<( {\mathbf{lambda}} {\mathbf{lambda}} {\mathbf{lambda}} )\>
\item \<( {\mathbf{lambda}} {\mathbf{lambda}} ({\mathbf{lambda}} {\mathbf{lambda}}))\>
\item None of the above.
\end{enumerate}

\item Below, write a Haskell data type declaration which represents \<Exp\>.

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

{\bf Directions.} Below, you will find a BNF grammar:
\begin{haskell}
Plant &::=&\relax leaf | (list Plant stem Plant) | (list Plant)
\end{haskell}

\item Circle those below that are in the language of \<Plant\>.
\begin{enumerate}[(a)]
\item \<leaf\>
\item \<(list stem)\>
\item \<(list (list leaf stem leaf) stem (list leaf))\>
\item \<(list (list (list leaf)))\>
\item All of the above.
\end{enumerate}

\item Circle the data declaration which best represents \<Plant\>.
\begin{enumerate}[(a)]
\item \verb+data Plant = Leaf | Two [(Plant,String,Plant)] | One [Plant]+
\item \verb+data Plant = LeafStem String | Two [(Plant,Plant,Plant)] | One [Plant]+
\item \verb+data Plant = Leaf | Stem | Two [(Plant,Stem,Plant)] | One [Plant]+
\item \verb+data Plant = Leaf | Two (Plant,Plant) | One Plant+
\item \verb+data Plant = Leaf | List | Stem | Four Plant Plant Plant Plant | Two Plant Plant+
\end{enumerate}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

{\bf Directions.} Say we introduce a mysterious new kind of let-binding to the TigerScheme interpreter called \verb+let?+.  ``Mystery let'' has the same syntactic form as other forms we have seen this semester; here is an example:
\begin{verbatim}
                (let? ((s 10)) 
                   (let? ((s 5))
                       s))
\end{verbatim}
Assume that the abstract syntax for \verb+let?+ is defined by this new clause in the \verb+Term+ data type: 
\begin{verbatim}
       data Term = ... | Let? [(String,Term)] Term
\end{verbatim}

\item {\bf (4 points)} Consulting the interpreter code on the next page, calculate the value of the above TigerScheme term by hand.  The value produced by the above \verb+Term+ is:
\begin{enumerate}[(a)]
\item \verb+(I 5)+
\item \verb+(I 10)+
\item \verb+error "Var s unbound\n"+
\item None of the above.
\end{enumerate}

\newpage

{\footnotesize
\begin{verbatim}
data Value = I Int | R Float | ConsCell Value Value 
           | FunVal ([Value]->Value) | NilVal | T | F 
           | Closure [String] Term Env
           | RecClosure String [String] Term Env
           | MystVal Term

eval :: Term -> Env -> Value
eval (Litint i) rho   = I i
eval (Var x) rho      = applyEnv rho x
eval Cons rho         = FunVal consVal
    where 
       consVal [v1,v2] = ConsCell v1 v2
       consVal _       = error "cons takes two and only two arguments\n"

eval Plus rho         = FunVal saddl
eval Times rho        = FunVal smull
eval Minus rho        = FunVal ssubl

eval (App (e:es)) rho = apply (eval e rho)
                              (map (\ t -> eval t rho) es)

eval (Lambda xs e) rho = Closure xs e rho

eval Nil rho               = NilVal
eval Car rho               = FunVal (\ [x] -> car x)
eval Cdr rho               = FunVal (\ [x] -> cdr x)

eval List rho              = FunVal mklist
     where mklist = foldr ConsCell NilVal

eval (Letexp bs body) rho  = eval body rho'
     where rho' = extendEnv vars vals rho
           vars = map fst bs
           es   = map snd bs
           vals = map (\ e -> eval e rho) es

eval (Let? bs body) rho  = eval body rho'
     where rho' = extendEnv vars vals rho
           vars = map fst bs
           es   = map snd bs
           vals = map MystVal es

apply (FunVal f) vs                 = f vs
apply (Closure xs body env) vs      = eval body env'
             where env' = extendEnv xs vs env
apply (RecClosure r xs body env) vs = eval body env'
             where env' = extendEnv xs' vs' env
                   xs'  = r : xs
                   vs'  = (RecClosure r xs body env) : vs

applyEnv rho x = case (lookup x rho) of
                   Just (MystVal e) -> eval e rho
                   Just v             -> v
                   Nothing            -> error ("Var "++x++" unbound\n")
\end{verbatim}
}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

{\bf Directions.} 
The following are definitions for binary trees and a function, \<reflect\>.
\begin{haskell}
\hskwd{data} Tree a &=&\relax Leaf a | Bin (Tree a) (Tree a)
\\
reflect (Leaf x) &=&\relax Leaf x
\\
reflect (Bin t1 t2) &=&\relax Bin (reflect t2) (reflect t1)
\end{haskell}
The following is a proof by induction of: forall \<t :: Tree a\>, \<reflect (reflect t) = t\>.
Notice that, off to the right side of each proof line, is a ``\<[\underline{~~~~}]\>''.

\begin{haskell}
\lefteqn{\mbox{\bf Base Case.}}
\\
\lefteqn{\mathit{reflect} ~(\mathit{reflect}~(\mathit{Leaf}~x))}
\\
&=&\relax reflect (Leaf x) ~~~~~~~~~~~~~~~& [\underline{~~~~}]
\\
&=&\relax Leaf x ~~~~~~~~~~~~~~~& [\underline{~~~~}]
\\
\vspace{1in}\\
\lefteqn{\mbox{\bf Inductive Case.}}
\\
\lefteqn{\mathit{reflect} ~(\mathit{reflect}~(\mathit{Bin}~t1~t2))}
\\
&=&\relax reflect (Bin (reflect t2) (reflect t1)) ~~~~~~~~~~~~~~~& [\underline{~~~~}]
\\
&=&\relax Bin (reflect (reflect t1)) (reflect (reflect t2)) ~~~~~& [\underline{~~~~}]
\\
&=&\relax Bin t1 (reflect (reflect t2)) ~~~~~~~~~~~~~~~& [\underline{~~~~}]
\\
&=&\relax Bin t1 t2 ~~~~~~~~~~~~~~~& [\underline{~~~~}]
\\
\end{haskell}

\item {\bf (4 points)} Fill in each ``\<[\underline{~~~~}]\>'' above with the letter of the justification for that step:
\begin{enumerate}[a.]
\item \<reflect (Leaf x) = x\>
\item \<reflect (Bin t1 t2) = Bin (reflect t2) (reflect t1)\>
\item Induction hypothesis.
\end{enumerate}
\end{enumerate}




%\begin{center}
%\begin{flushleft}
%{\bf Name:}
%\end{flushleft}
%
%{\bf Answer Sheet, CS4450/7450 Final, \displaydate{date}}
%
%\end{center}
%
%\begin{multicols}{2}
%\begin{enumerate}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\item \underline{~~~~~~~~~~~~~~~~~~~~}
%\end{enumerate}
%
%\end{multicols}


\end{document}





