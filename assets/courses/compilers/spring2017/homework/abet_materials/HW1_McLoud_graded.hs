module HW1_McLoud where

-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
--
-- 100/100, see explanation at bottom
--
-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

import Parsing

-- tokens for tuple opcodes

data Token = ASSIGN | WRITEI | READI | ADDI | SUBI | JUMP 
           | JNZ | LABEL | SP | BP | FP | R String
           | LITERAL String | M | COMMA | LPAREN 
           | RPAREN | LBRACKET | RBRACKET | PLUS |SCANEOF
           deriving (Show,Eq)


{-
-- test case
test = "(ASSIGN,BP,R99)\n (ASSIGN,SP,0)\n (JUMP,M[FP])\n (LABEL,3)"
test2 = "(ASSIGN,BP,BP)"
test3 = "(ASSIGN,BP,0)(ASSIGN,SP,0)(ASSIGN,FP,SP)(ASSIGN,M[FP],3)(ADDI,SP,FP,2)(JUMP,2)"
test4 = "(LABEL,0)(ADDI,SP,SP,1)(ADDI,SP,SP,1)(ASSIGN,R0,M[FP+4])(READI,M[FP+4])(ASSIGN,R1,M[FP+5])"
test5 ="(ASSIGN,R2,4)(ASSIGN,M[FP+5],R2)(ASSIGN,M[SP],4)(ADDI,SP,SP,1)(ASSIGN,M[SP],FP)(ADDI,SP,SP,1)(SUBI,M[SP],SP,2)(ADDI,SP,SP,1)(ASSIGN,R3,M[FP+4])(ASSIGN,R4,R3)"
test6 ="(ASSIGN,M[SP],R4)(ADDI,SP,SP,1)(ASSIGN,R5,M[FP+5])(ASSIGN,R6,R5)"
test7 ="(ASSIGN,M[SP],R6)(ADDI,SP,SP,1)(SUBI,FP,SP,5)(JUMP,1)(LABEL,4)(ASSIGN,SP,M[FP+2])(ASSIGN,FP,M[FP+1])"
test8 ="(JUMP,M[FP])(LABEL,1)(ASSIGN,R7,M[FP+3])(ASSIGN,R8,R7)(ASSIGN,R9,M[FP+4])(ASSIGN,R10,R9)(ADDI,R11,R8,R10)(WRITEI,R11)(JUMP,M[FP])(LABEL,2)(ADDI,SP,SP,1)(ASSIGN,R12,M[FP+5])"
test9 ="(READI,M[FP+5])(ASSIGN,R13,M[FP+5])(ASSIGN,R14,R13)(WRITEI,R14)(ASSIGN,R15,M[FP+6])(ASSIGN,R16,R15)(WRITEI,R16)(ASSIGN,M[SP],5)"
test10 ="(ADDI,SP,SP,1)(ASSIGN,M[SP],FP)(ADDI,SP,SP,1)(SUBI,M[SP],SP,2)(ADDI,SP,SP,1)(ASSIGN,R17,M[FP+5])(ASSIGN,R18,R17)(ASSIGN,M[SP],R18)(ADDI,SP,SP,1)(SUBI,FP,SP,4)(JUMP,0)(LABEL,5)(ASSIGN,SP,M[FP+2])(ASSIGN,FP,M[FP+1])(JUMP,M[FP])(LABEL,3)"
-}


run (P x) inp = x inp

--
-- define which strings constitute tokens
--
recognize :: String -> Token
recognize str = case str of
  "ASSIGN"  -> ASSIGN
  "WRITEI"  -> WRITEI
  "READI"   -> READI
  "ADDI"    -> ADDI
  "SUBI"    -> SUBI
  "JUMP"    -> JUMP
  "JNZ"     -> JNZ
  "SP"      -> SP
  "BP"      -> BP
  "FP"      -> FP
  _         -> LABEL


opcode :: Parser Token
opcode = do
  i <- optok
  return (recognize i)


--symbols that constitute tokens

number :: Parser Token
number = do
  space
  n <- many1 digit
  space
  return (LITERAL n)

lparen :: Parser Token
lparen = do
  symbol "("
  return LPAREN

rparen :: Parser Token
rparen = do
  symbol ")"
  return RPAREN

lbracket :: Parser Token
lbracket = do
  symbol "["
  return LBRACKET

rbracket :: Parser Token
rbracket = do
  symbol "]"
  return RBRACKET

comma :: Parser Token
comma = do
  symbol ","
  return COMMA

memref :: Parser Token
memref = do
     symbol "M"
     return M 

reg :: Parser Token
reg = do
    symbol "R"
    str <- many1 digit
    return (R str)

plus :: Parser Token
plus = do
     symbol "+"
     return PLUS
     

optok :: Parser String
optok = do 
           space
           x <- upper
           xs <- many1 upper
           space
           return (x:xs)


lexer :: Parser Token
lexer = opcode
          +++ number
          +++ lparen
          +++ rparen
          +++ comma
          +++ lbracket
          +++ rbracket
          +++ memref
          +++ reg
          +++ plus

tuplelex :: String -> Maybe [Token]
tuplelex inp = case run (many lexer) inp of
                    [(toks,"")] -> Just (toks ++ [SCANEOF])
                    _           -> Nothing

--
-- Grading
--
              
test1 = "(ASSIGN,BP,R99)\n (ASSIGN,SP,0)\n (JUMP,M[FP])\n (LABEL,3) "

test2 = "(ASSIGN,BP,0) (ASSIGN,SP,0) (ASSIGN,FP,SP) (ASSIGN,M[FP],3) (ADDI,SP,FP,2) (JUMP,2) (LABEL,0) (ADDI,SP,SP,1) (ADDI,SP,SP,1) (ASSIGN,R0,M[FP+4]) (READI,M[FP+4]) (ASSIGN,R1,M[FP+5]) (ASSIGN,R2,4) (ASSIGN,M[FP+5],R2) (ASSIGN,M[SP],4) (ADDI,SP,SP,1) (ASSIGN,M[SP],FP) (ADDI,SP,SP,1) (SUBI,M[SP],SP,2) (ADDI,SP,SP,1) (ASSIGN,R3,M[FP+4]) (ASSIGN,R4,R3) (ASSIGN,M[SP],R4) (ADDI,SP,SP,1) (ASSIGN,R5,M[FP+5]) (ASSIGN,R6,R5) (ASSIGN,M[SP],R6) (ADDI,SP,SP,1) (SUBI,FP,SP,5) (JUMP,1) (LABEL,4) (ASSIGN,SP,M[FP+2]) (ASSIGN,FP,M[FP+1]) (JUMP,M[FP]) (LABEL,1) (ASSIGN,R7,M[FP+3]) (ASSIGN,R8,R7) (ASSIGN,R9,M[FP+4]) (ASSIGN,R10,R9) (ADDI,R11,R8,R10) (WRITEI,R11) (JUMP,M[FP]) (LABEL,2) (ADDI,SP,SP,1) (ASSIGN,R12,M[FP+5]) (READI,M[FP+5]) (ASSIGN,R13,M[FP+5]) (ASSIGN,R14,R13) (WRITEI,R14) (ASSIGN,R15,M[FP+6]) (ASSIGN,R16,R15) (WRITEI,R16) (ASSIGN,M[SP],5) (ADDI,SP,SP,1) (ASSIGN,M[SP],FP) (ADDI,SP,SP,1) (SUBI,M[SP],SP,2) (ADDI,SP,SP,1) (ASSIGN,R17,M[FP+5]) (ASSIGN,R18,R17) (ASSIGN,M[SP],R18) (ADDI,SP,SP,1) (SUBI,FP,SP,4) (JUMP,0) (LABEL,5) (ASSIGN,SP,M[FP+2]) (ASSIGN,FP,M[FP+1]) (JUMP,M[FP]) (LABEL,3)"

ans1 = Just [LPAREN,ASSIGN,COMMA,BP,COMMA,R "99",RPAREN,LPAREN,ASSIGN,COMMA,SP,COMMA,LITERAL "0",RPAREN,LPAREN,JUMP,COMMA,M,LBRACKET,FP,RBRACKET,RPAREN,LPAREN,LABEL,COMMA,LITERAL "3",RPAREN,SCANEOF]

ans2 = Just [LPAREN,ASSIGN,COMMA,BP,COMMA,LITERAL "0",RPAREN,LPAREN,ASSIGN,COMMA,SP,COMMA,LITERAL "0",RPAREN,LPAREN,ASSIGN,COMMA,FP,COMMA,SP,RPAREN,LPAREN,ASSIGN,COMMA,M,LBRACKET,FP,RBRACKET,COMMA,LITERAL "3",RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,FP,COMMA,LITERAL "2",RPAREN,LPAREN,JUMP,COMMA,LITERAL "2",RPAREN,LPAREN,LABEL,COMMA,LITERAL "0",RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,SP,COMMA,LITERAL "1",RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,SP,COMMA,LITERAL "1",RPAREN,LPAREN,ASSIGN,COMMA,R "0",COMMA,M,LBRACKET,FP,PLUS,LITERAL "4",RBRACKET,RPAREN,LPAREN,READI,COMMA,M,LBRACKET,FP,PLUS,LITERAL "4",RBRACKET,RPAREN,LPAREN,ASSIGN,COMMA,R "1",COMMA,M,LBRACKET,FP,PLUS,LITERAL "5",RBRACKET,RPAREN,LPAREN,ASSIGN,COMMA,R "2",COMMA,LITERAL "4",RPAREN,LPAREN,ASSIGN,COMMA,M,LBRACKET,FP,PLUS,LITERAL "5",RBRACKET,COMMA,R "2",RPAREN,LPAREN,ASSIGN,COMMA,M,LBRACKET,SP,RBRACKET,COMMA,LITERAL "4",RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,SP,COMMA,LITERAL "1",RPAREN,LPAREN,ASSIGN,COMMA,M,LBRACKET,SP,RBRACKET,COMMA,FP,RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,SP,COMMA,LITERAL "1",RPAREN,LPAREN,SUBI,COMMA,M,LBRACKET,SP,RBRACKET,COMMA,SP,COMMA,LITERAL "2",RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,SP,COMMA,LITERAL "1",RPAREN,LPAREN,ASSIGN,COMMA,R "3",COMMA,M,LBRACKET,FP,PLUS,LITERAL "4",RBRACKET,RPAREN,LPAREN,ASSIGN,COMMA,R "4",COMMA,R "3",RPAREN,LPAREN,ASSIGN,COMMA,M,LBRACKET,SP,RBRACKET,COMMA,R "4",RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,SP,COMMA,LITERAL "1",RPAREN,LPAREN,ASSIGN,COMMA,R "5",COMMA,M,LBRACKET,FP,PLUS,LITERAL "5",RBRACKET,RPAREN,LPAREN,ASSIGN,COMMA,R "6",COMMA,R "5",RPAREN,LPAREN,ASSIGN,COMMA,M,LBRACKET,SP,RBRACKET,COMMA,R "6",RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,SP,COMMA,LITERAL "1",RPAREN,LPAREN,SUBI,COMMA,FP,COMMA,SP,COMMA,LITERAL "5",RPAREN,LPAREN,JUMP,COMMA,LITERAL "1",RPAREN,LPAREN,LABEL,COMMA,LITERAL "4",RPAREN,LPAREN,ASSIGN,COMMA,SP,COMMA,M,LBRACKET,FP,PLUS,LITERAL "2",RBRACKET,RPAREN,LPAREN,ASSIGN,COMMA,FP,COMMA,M,LBRACKET,FP,PLUS,LITERAL "1",RBRACKET,RPAREN,LPAREN,JUMP,COMMA,M,LBRACKET,FP,RBRACKET,RPAREN,LPAREN,LABEL,COMMA,LITERAL "1",RPAREN,LPAREN,ASSIGN,COMMA,R "7",COMMA,M,LBRACKET,FP,PLUS,LITERAL "3",RBRACKET,RPAREN,LPAREN,ASSIGN,COMMA,R "8",COMMA,R "7",RPAREN,LPAREN,ASSIGN,COMMA,R "9",COMMA,M,LBRACKET,FP,PLUS,LITERAL "4",RBRACKET,RPAREN,LPAREN,ASSIGN,COMMA,R "10",COMMA,R "9",RPAREN,LPAREN,ADDI,COMMA,R "11",COMMA,R "8",COMMA,R "10",RPAREN,LPAREN,WRITEI,COMMA,R "11",RPAREN,LPAREN,JUMP,COMMA,M,LBRACKET,FP,RBRACKET,RPAREN,LPAREN,LABEL,COMMA,LITERAL "2",RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,SP,COMMA,LITERAL "1",RPAREN,LPAREN,ASSIGN,COMMA,R "12",COMMA,M,LBRACKET,FP,PLUS,LITERAL "5",RBRACKET,RPAREN,LPAREN,READI,COMMA,M,LBRACKET,FP,PLUS,LITERAL "5",RBRACKET,RPAREN,LPAREN,ASSIGN,COMMA,R "13",COMMA,M,LBRACKET,FP,PLUS,LITERAL "5",RBRACKET,RPAREN,LPAREN,ASSIGN,COMMA,R "14",COMMA,R "13",RPAREN,LPAREN,WRITEI,COMMA,R "14",RPAREN,LPAREN,ASSIGN,COMMA,R "15",COMMA,M,LBRACKET,FP,PLUS,LITERAL "6",RBRACKET,RPAREN,LPAREN,ASSIGN,COMMA,R "16",COMMA,R "15",RPAREN,LPAREN,WRITEI,COMMA,R "16",RPAREN,LPAREN,ASSIGN,COMMA,M,LBRACKET,SP,RBRACKET,COMMA,LITERAL "5",RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,SP,COMMA,LITERAL "1",RPAREN,LPAREN,ASSIGN,COMMA,M,LBRACKET,SP,RBRACKET,COMMA,FP,RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,SP,COMMA,LITERAL "1",RPAREN,LPAREN,SUBI,COMMA,M,LBRACKET,SP,RBRACKET,COMMA,SP,COMMA,LITERAL "2",RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,SP,COMMA,LITERAL "1",RPAREN,LPAREN,ASSIGN,COMMA,R "17",COMMA,M,LBRACKET,FP,PLUS,LITERAL "5",RBRACKET,RPAREN,LPAREN,ASSIGN,COMMA,R "18",COMMA,R "17",RPAREN,LPAREN,ASSIGN,COMMA,M,LBRACKET,SP,RBRACKET,COMMA,R "18",RPAREN,LPAREN,ADDI,COMMA,SP,COMMA,SP,COMMA,LITERAL "1",RPAREN,LPAREN,SUBI,COMMA,FP,COMMA,SP,COMMA,LITERAL "4",RPAREN,LPAREN,JUMP,COMMA,LITERAL "0",RPAREN,LPAREN,LABEL,COMMA,LITERAL "5",RPAREN,LPAREN,ASSIGN,COMMA,SP,COMMA,M,LBRACKET,FP,PLUS,LITERAL "2",RBRACKET,RPAREN,LPAREN,ASSIGN,COMMA,FP,COMMA,M,LBRACKET,FP,PLUS,LITERAL "1",RBRACKET,RPAREN,LPAREN,JUMP,COMMA,M,LBRACKET,FP,RBRACKET,RPAREN,LPAREN,LABEL,COMMA,LITERAL "3",RPAREN,SCANEOF]


out1 = tuplelex test1
out2 = tuplelex test2

{-
λ> out1 == ans1
True
λ> out2 == ans2
True

Therefore, score = 100/100

-}                    
