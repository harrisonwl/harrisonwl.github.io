                  

   
@article{procter16,                  
 author = {Procter, Adam and Harrison, William L. and Graves, Ian and Becchi, Michela and Allwein, Gerard},
 title = {A Principled Approach to Secure Multi-Core Processor Design with ReWire},
	journal = {ACM Transactions on Embedded Computing Systems (to appear)},
	year = {2016},
	abstract = {There is no such thing as high assurance without high assurance hardware. High assurance hardware is essential, because any and all high assurance systems ultimately depend on hardware that conforms to, and does not undermine, critical system properties and invariants. And yet, high assurance hardware development is stymied by the conceptual gap between formal methods and hardware description languages used by engineers. This paper advocates a {\em semantics-directed} approach to bridge this conceptual gap. We present a case study in the design of secure processors, which are formally derived via principled techniques grounded in functional programming and equational reasoning. The case study comprises the development of secure single- and dual-core variants of a single processor, both based on a common semantic specification of the ISA. We demonstrate via formal equational reasoning that the dual-core processor respects a ``no-write-down'' information flow policy. The semantics-directed approach enables a modular and extensible style of system design and verification. The secure processors require only a very small amount of additional code to specify and implement, and their security verification arguments are concise and readable. Our approach rests critically on ReWire, a functional programming language providing a suitable foundation for formal verification of hardware designs. This case study demonstrates both ReWire's expressiveness as a programming language and its power as a framework for formal, high-level reasoning about hardware systems.
},
        url_Paper = "https://harrisonwl.github.io/assets/papers/tecs16.pdf",
}

@inproceedings{harrison16,
   title={A Programming Model for Reconfigurable Computing Based in Functional Concurrency},
   author = {Harrison, William L. and Procter, Adam and Graves, Ian and Becchi, Michela and Allwein, Gerard},
   booktitle = {Proceedings of the 11th International Symposium on Reconfigurable Communication-centric Systems-on-Chip (ReCoSoC 2016)},
   year = {2016},
   pages = {},
   url_Paper = "https://harrisonwl.github.io/assets/papers/recosoc16.pdf",
   url_Slides = "https://harrisonwl.github.io/assets/papers/slides-recosoc16.pdf",
  }

@inproceedings{harrison16a,
  author = {Graves, Ian and Procter, Adam M. and Harrison, William L. and Allwein, Gerard},
  booktitle = {Proceedings of the 2015 International Conference on
Field-Programmable Technology (FPT '15)},
  isbn = {978-1-4673-9091-0},
  pages = {160-171},
  publisher = {IEEE},
  title = {Provably Correct Development of reconfigurable hardware designs via equational reasoning.},
  year = 2016,
  url_Paper = "https://harrisonwl.github.io/assets/papers/fpt15.pdf",
  url_Slides = "https://harrisonwl.github.io/assets/papers/slides-fpt15.pdf",
}

  
@inproceedings{graves15a,
  author = {Graves, Ian and Procter, Adam M. and Harrison, William L. and Allwein, Gerard},
  booktitle = {Proceedings of the 2015 International Conference on
Field-Programmable Technology (FPT '15)},
  isbn = {978-1-4673-9091-0},
  pages = {160-171},
  publisher = {IEEE},
  title = {Provably Correct Development of reconfigurable hardware designs via equational reasoning.},
  year = 2015,
  url_Paper = "https://harrisonwl.github.io/assets/papers/fpt15.pdf",
  url_Slides = "https://harrisonwl.github.io/assets/papers/slides-fpt15.pdf",
}


@inproceedings{procter15,
 author = {Procter, Adam and Harrison, William L. and Graves, Ian and Becchi, Michela and Allwein, Gerard},
 title = {Semantics Driven Hardware Design, Implementation, and Verification with ReWire},
 booktitle = {Proceedings of the 16th ACM SIGPLAN/SIGBED Conference on Languages, Compilers and Tools for Embedded Systems 2015 CD-ROM},
 series = {LCTES'15},
 year = {2015},
 isbn = {978-1-4503-3257-6},
 location = {Portland, OR, USA},
 pages = {13:1--13:10},
 articleno = {13},
 numpages = {10},
 abstract = "There is no such thing as high assurance without high assurance hardware. High assurance hardware is essential, because any and all high assurance systems ultimately depend on hardware that conforms to, and does not undermine, critical system properties and invariants. And yet, high assurance hardware development is stymied by the conceptual gap between formal methods and hardware description languages used by engineers. This paper presents ReWire, a functional programming language providing a suitable foundation for formal verification of hardware designs, and a compiler for that language that translates high-level, semantics-driven designs directly into working hardware. ReWire's design and implementation are presented, along with a case study in the design of a secure multicore processor, demonstrating both ReWire's expressiveness as a programming language and its power as a framework for formal, high-level reasoning about hardware systems.",                 
 url_Paper = {https://harrisonwl.github.io/assets/papers/lctes15.pdf},
} 

                  

@incollection{graves15,
year={2015},
booktitle={Applied Reconfigurable Computing},
volume={9040},
series={Lecture Notes in Computer Science},
editor={Sano, Kentaro and Soudris, Dimitrios and Huebner, Michael and Diniz, Pedro C.},
title={Hardware Synthesis from Functional Embedded Domain-Specific Languages: A Case Study in Regular Expression Compilation},
author={Graves, Ian and Procter, Adam and Harrison, William L. and Becchi, Michela and Allwein, Gerard},
pages={41-52},
abstract = "Although FPGAs have the potential to bring software-like flexibility and agility to the hardware world, designing for FPGAs remains a difficult task divorced from standard software engineering norms. A better programming flow would go far towards realizing the potential of widely deployed, programmable hardware. We propose a general methodology based on domain specific languages embedded in the functional language Haskell to bridge the gap between high level abstractions that support programmer productivity and the need for high performance in FPGA circuit implementations. We illustrate this methodology with a framework for regular expression to hardware compilers, written in Haskell, that supports high programmer productivity while producing circuits whose performance matches and, indeed, exceeds that of a state of the art, hand-optimized VHDL-based tool. For example, after applying a  novel optimization pass, throughput increased an average of 28.3 percent over the state of the art tool for one set of benchmarks.",
 url_Paper = "https://harrisonwl.github.io/assets/papers/arc15.pdf",
}


@inproceedings{icfpt13,
   title = "Semantics-directed Machine Architecture in ReWire",
   booktitle = "Proceedings of the 2013 International Conference on Field Programmable Technology",
   author = "Adam Procter and William L. Harrison and Ian Graves and Michela Becchi and Gerard Allwein",
   year = 2013,
month={Dec}, 
pages={446-449}, 
abstract={The functional programming community has developed a number of powerful abstractions for dealing with diverse programming models in a modular way. Beginning with a core of pure, side effect free computation, modular monadic semantics (MMS) allows designers to construct domain-specific languages by adding layers of semantic features, such as mutable state and I/O, in an a' la carte fashion. In the realm of interpreter and compiler construction, the benefits of this approach are manifold and well explored. This paper advocates bringing the tools of MMS to bear on hardware design and verification. In particular, we shall discuss a prototype compiler called ReWire which translates high-level MMS hardware specifications into working circuits on FPGAs. This enables designers to tackle the complexity of hardware design in a modular way, without compromising efficiency.}, 
keywords={electronic engineering computing;field programmable gate arrays;formal verification;functional programming;program compilers;FPGA;MMS;ReWire;compiler construction;diverse programming models;domain-specific languages;functional programming;hardware design;modular monadic semantics;semantics-directed machine architecture;verification;Field programmable gate arrays;Hardware;Microcontrollers;Ports (Computers);Random access memory;Registers;Semantics}, 
    url_Paper = "https://harrisonwl.github.io/assets/papers/icfpt13.pdf",
}

@inproceedings{qasa13,
   title = "Quantitative Analysis of Error Injection Covert Channels",
   booktitle = "Proceedings of the International Workshop on Quantitative Aspects in Security Assurance (QASA13)",
   author = "Robert Harrison and William L. Harrison",
   year = 2013,
   abstract = "Covert channels are mechanisms for communication where a legitimate channel carries a hidden message, and where the hidden message is conveyed using legal operations of the legitimate channel. Quantitative modeling of the response of the covert channel to noise results in an enhanced understanding of the channel and delimits the range of conditions under which a covert channel can operate effectively. The analysis of two covert channels using the confusion matrix and noise models shows that the techniques presented in this paper are widely applicable to covert information flows in noisy channels.",               
    url_Paper = "https://harrisonwl.github.io/assets/papers/interchannel.pdf",
}

@article{LLP13,
	author = {Gerard Allwein and William Harrison and David Andrews},
	title = {Simulation logic},
	journal = {Logic and Logical Philosophy},
	volume = {0},
	number = {0},
	year = {2013},
	keywords = {modal logic; simulations; Hilbert systems; Kripke; modal algebras},
	abstract = {Simulation relations have been discovered in many areas: Computer Science, philosophical and modal logic, and set theory. However, the simulation condition is strictly a first-order logic statement. We extend modal logic with modalities and axioms, the latter's modeling conditions are the simulation conditions. The modalities are normal, i.e., commute with either conjunctions or disjunctions and preserve either Truth or Falsity (respectively). The simulations are considered arrows in a category where the objects are descriptive, general frames. One can augment the simulation modalities by axioms for requiring the underlying modeling simulations to be bisimulations or to be p-morphisms. The modal systems presented are multi-sorted and both sound and complete with respect to their algebraic and Kripke semantics.},
   url_Paper = "https://harrisonwl.github.io/assets/papers/llp2014.pdf",
}

@inproceedings{ICFEM12,
   title = "The Confinement Problem in the Presence of Faults",
   booktitle = "Proceedings of the 2012 International Conference on Formal Engineering Methods",
   author = "William L. Harrison, Adam Procter and Gerard Allwein",
   year = 2012,
   url_Paper = "https://harrisonwl.github.io/assets/papers/icfem12.pdf",
  abstract = "In this paper, we establish a semantic foundation for the safe
execution of untrusted code. Our approach extends Moggi's computational $\lambda$-calculus in two dimensions with operations for asynchronous concurrency, shared state and software faults and with an effect type system $\grave{a}$ la Wadler providing fine-grained control of effects. An equational system for fault isolation is exhibited and its soundness demonstrated with a semantics based on monad transformers. Our formalization of the equational system in the Coq theorem prover is discussed. We argue that the approach may be generalized to capture other safety properties, including information flow security.",
   }                  
                  
@inproceedings{SSV12,
   title = "Formal Semantics of Heterogeneous CUDA-C: A Modular Approach with Applications",
   booktitle = "Proceedings of the 2012 Systems Software Verification Conference",
   author = "Chris Hathhorn, Michela Becchi, William L. Harrison and Adam Procter",
   year = 2012,
   url_Paper = "https://harrisonwl.github.io/assets/papers/ssv12.pdf",
  abstract = "We extend an off-the-shelf, executable formal semantics of C (Ellison and Rosiu's K Framework semantics) with the core features of CUDA-C. The hybrid CPU/GPU computation model of CUDA-C presents challenges not just for programmers, but also for practitioners of formal methods. Our formal semantics helps expose and clarify these issues. We demonstrate the usefulness of our semantics by generating a tool from it
capable of detecting some race conditions and deadlocks in CUDA-C programs. We discuss limitations of our model and argue that its extensibility can easily
enable a wider range of verification tasks.",
   }                  
                  
@inproceedings{NCL12,
   title = "Simulation Logic",
   booktitle = "Proceedings of the 2012 Conference on Non-Classical Logics",
   author = "Gerard Allwein, William L. Harrison and David Andrews",
   year = 2012,
   url_Paper = "https://harrisonwl.github.io/assets/papers/ncl12.pdf",
  abstract = "Simulation relations have been discovered in many areas: Computer Science, philosophical and modal logic, and set theory. However, the simulation condition is strictly a first-order logic statement. We extend modal logic with modalities and axioms, the latter's modeling conditions are the simulation conditions. The modalities are normal, i.e., commute with either conjunctions or disjunctions and preserve either Truth or Falsity (respectively). The simulations are considered arrows in a category where the objects are descriptive, general frames. One can augment the simulation modalities by axioms for requiring the underlying modeling simulations to be bisimulations or to be p-morphisms. The modal systems presented are multi-sorted and both sound and complete with respect to their algebraic and Kripke semantics.",
   }                  
                  
@inproceedings{TFP12,
   title = "The Design of a Practical Proof Checker for a Lazy Functional Language",
   booktitle = "Proceedings of the 2012 Trends in Functional Programming Conference",
   author = "Adam Procter, William L. Harrison and Aaron Stump",
   year = 2012,
   url_Paper = "https://harrisonwl.github.io/assets/papers/tfp12.pdf",
  abstract = "Pure, lazy functional languages like Haskell provide a sound basis for formal reasoning about programs in an equational style. In
practice, however, equational reasoning is underutilized. We suggest that part
of the reason for this is the lack of accessible tools for developing
machine-checked equational reasoning proofs. This paper outlines the design of
MProver, a system which fills just that niche. MProver features first-class
support for reasoning about potentially undefined computations (particularly
important in a lazy setting), and an extended notion of Haskell-like type
classes, enabling a highly modular style of program verification that closely
follows familiar functional programming idioms.",
   }                  
                  
@inproceedings{ERSA2011a,
   title = "A Channel Theoretic Account of Separation Security",
   booktitle = "Proceedings of the 2011 International Conference on Engineering Reconfigurable Systems and Algorithms (ERSA11)",
   author = "Gerard Allwein and William L. Harrison",
   year = 2011,
   url_Paper = "https://harrisonwl.github.io/assets/papers/ersa2011a.pdf",
  abstract = "It has long been held that information flow security models should be organized with respect to a theory of information, but typically they are not. The appeal of a information-theoretic foundation for information flow security seems natural, compelling and, indeed, almost tautological. This article illustrates how channel theory---a theory of information based in logic---can provide a basis for noninterference style security models. The evidence presented here suggests that channel theory is a useful organizing principle for information flow security.",
   }

@inproceedings{ERSA2011b,
   title = "Towards Semantics-directed System Design and Synthesis",
   booktitle = "Proceedings of the 2011 International Conference on Engineering Reconfigurable Systems and Algorithms (ERSA11)",
   author = "William L. Harrison and Benjamin Schulz and Adam Procter and Andrew Lukefahr and Gerard Allwein",
   year = 2011,
      url_Paper = "https://harrisonwl.github.io/assets/papers/ersa2011b.pdf",
  abstract = "High assurance systems have been defined as systems ``you would bet your life on.'' This article discusses the application of a form of functional programming---what we call ``monadic programming''---to the generation of high assurance and secure systems. Monadic programming languages leverage algebraic structures from denotational semantics and functional programming---monads---as a flexible, modular organizing principle for secure system design and implementation. Monadic programming languages are domain-specific functional languages that are both sufficiently expressive to express essential system behaviors and semantically straightforward to support formal verification.",
   }   

@article{LLP10,
 author = "Gerard Allwein and Yingrui Yang and William L. Harrison",
 title  = "Qualitative Decision Theory via Channel Theory",
 journal = "Logic and Logical Philosophy",
 vol = 20,
 year = 2011,
 pages = {81-110},
 note = {Extended version of \cite{AllweinYangHarrison:2010}},
       url_Paper = "https://harrisonwl.github.io/assets/papers/llp2011.pdf",
  abstract = "We recast parts of decision theory in terms of channel theory
concentrating on qualitative issues. Channel theory allows one to move
between model theoretic and language theoretic notions as is necessary for
an adequate covering. Doing so clari?es decision theory and presents the
opportunity to investigate alternative formulations. As an example, we take
some of Savage's notions of decision theory and recast them within channel
theory. In place of probabilities, we use a particular logic of preference. We
introduce a logic for describing actions separate from the logic of preference
over actions. The structures introduced by channel theory that represent
the decision problems can be seen to be an abstract framework. This framework is very accommodating to changing the nature of the decision problems
to handle different aspects or theories about decision making.",
}

@inProceedings {AllweinYangHarrison:2010,
author    ={Gerard Allwein and Yingrui Yang and William S. Harrison},
title        ={Decision Theory via Channel Theory},
booktitle    ={Proceedings of the Logic in Cognitive Science Conference, 2010, Logic and Logical Philosophy Journal},
publisher    ={The Nicolaus Copernicus University Press},
year        ={2010},
}

@inproceedings{AiML10,
  author    = {Gerard Allwein and William L. Harrison},
  title     = {Partially-ordered Modalities},
  booktitle = {Advances in Modal Logic},
  year      = {2010},
  pages     = {1-21},
        url_Paper = "https://harrisonwl.github.io/assets/papers/aiml10.pdf",
  abstract = "
Modal logic is extended by partially ordering the modalities. The modalities are normal, i.e., commute
with either conjunctions or disjunctions and preserve either Truth or Falsity (respectively). The partial
order does not conflict with type of modality (K, S4, etc.) although this paper will concentrate on S4
since partially ordered S4 systems appear to be numerous. The partially-ordered normal modal systems
considered are both sound and complete. Hilbert and Gentzen systems are given. A cut-elimination theorem
holds (for partially ordered S4), and the Hilbert and Gentzen systems present the same logic. The partial
order induces a 2-category structure on a coalgebraic formulation of descriptive frames. Channel theory is
used to `move' modal logics when the source and target languages may be dierent. A particular partially
ordered modal system is shown to be applicable to security properties",
}

@inproceedings{dslwc09,
author = {W. Harrison and A. Procter and J. Agron and G. Kimmel and G. Allwein},
 title = {Model-Driven Engineering from Modular Monadic Semantics: Implementation Techniques Targeting Hardware and Software},
 booktitle = {DSL '09: Proc. of the IFIP TC 2 Working Conference on Domain-Specific Languages},
 year = {2009},
 pages = {20--44},
       url_Paper = "https://harrisonwl.github.io/assets/papers/dsl09.pdf",
  abstract = "Recent research has shown how the formal modeling of concurrent systems can benefit from monadic structuring. With this approach, a formal system model is really a program in a domain specific language defined by a monad for shared-state concurrency. Can these models be compiled into efficient implementations?  This paper addresses this question and presents an overview of techniques for compiling monadic concurrency models directly into reasonably efficient software and hardware implementations. The implementation techniques described in this article form the basis of a semantics-directed approach to model-driven engineering.",
 } 


@article{HarrisonHook09,
 author = {Harrison, William L. and Hook, James},
 title = {Achieving information flow security through monadic control of effects},
 journal = {J. Comput. Secur.},
 volume = {17},
 issue = {5},
 month = {October},
 year = {2009},
 pages = {599--653},
 numpages = {55},
 publisher = {IOS Press},
 address = {Amsterdam, The Netherlands, The Netherlands},
       url_Paper = "https://harrisonwl.github.io/assets/papers/jcs09.pdf",
  abstract = "This paper advocates a novel approach to the construction of secure
software: controlling information flow and maintaining integrity via
monadic encapsulation of effects. This approach is {\em constructive},
relying on properties of monads and monad transformers to build,
verify, and extend secure software systems. We illustrate this
approach by construction of abstract operating systems called {\em
  separation kernels}. Starting from a mathematical model of
shared-state concurrency based on monads of resumptions and state, we
outline the development by stepwise refinements of separation kernels
supporting Unix-like system calls, interdomain communication,  and a
formally verified security policy (domain separation). Because monads
may be easily and safely represented within any pure, higher-order,
typed functional language, the resulting system models may be directly
realized within a language such as Haskell.",
} 

@inproceedings{HarrisonAllwein08,
author = {William L. Harrison and Gerard Allwein and Andy Gill and Adam Procter},
title = {Asynchronous Exceptions as an Effect},
booktitle = {Proceedings of the Mathematics of Program Construction (MPC08)},
year = {2008},
pages = {153--176},
numpages = {24},
      url_Paper = "https://harrisonwl.github.io/assets/papers/mpc08.pdf",
  abstract = "Asynchronous interrupts abound in computing systems, yet they remain a
thorny concept for both programming and verification practice.
The ubiquity of interrupts underscores the importance of developing
programming models to aid the development and verification of
interrupt-driven programs. 
The research reported here recognizes asynchronous interrupts as a
computational effect and encapsulates them as a building block in
modular monadic semantics.
The resulting modular semantic model can serve as both a guide for
functional programming with interrupts and as a formal basis for reasoning about
interrupt-driven computation as well.",
}

@inproceedings{Haskell08,
 author = {Kariotis, Pericles S. and Procter, Adam M. and Harrison, William L.},
 title = {Making monads first-class with template haskell},
 booktitle = {Proceedings of the first ACM SIGPLAN Symposium on Haskell},
 series = {Haskell '08},
 year = {2008},
 location = {Victoria, BC, Canada},
 pages = {99--110},
 numpages = {12},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {domain-specific languages, monads, staged programming},
       url_Paper = "https://harrisonwl.github.io/assets/papers/haskell08.pdf",
  abstract = "Monads as an organizing principle for programming and semantics are notoriously difficult to grasp, yet they are a central and powerful abstraction in Haskell. This paper introduces a domain-specific language, MonadLab, that simplifies the construction of monads, and describes its implementation in Template Haskell. MonadLab makes monad construction truly first class, meaning that arcane theoretical issues with respect to monad transformers are completely hidden from the programmer. The motivation behind the design of MonadLab is to make monadic programming in Haskell simpler while providing a tool for non-Haskell experts that will assist them in understanding this powerful abstraction.",
} 


@article{CheapThreads,
  author =       "William L. Harrison",
  title =        "Cheap (But Functional) Threads",
  journal =      "Higher Order and Symbolic Computation (accepted for publication)",
  note = "45 pages. Available by request.",
  hdraft = "yes",
  note = {Draft version},
  abstract = "This article demonstrates how a powerful and expressive abstraction 
from concurrency theory plays a dual role as a programming tool 
for concurrent applications and as a foundation for their verification.
This abstraction---monads of resumptions expressed using monad 
transformers---is \emph{cheap}: it is easy to understand, easy to 
implement, and easy to reason about.
We illustrate the expressiveness of the resumption monad with the 
construction of an exemplary multitasking operating system kernel 
with process forking, preemption, message passing, and 
synchronization constructs in the pure functional programming 
language Haskell.
Because resumption computations are stream-like structures, reasoning 
about this kernel may be posed as reasoning about streams, a problem 
which is well-understood. And, as an example, this article 
illustrates how a liveness property---fairness---is proven and 
especially how the resumption-monadic structure promotes such 
verifications.",
}

@InProceedings{APLAS06,
  author =       "William Harrison",
  title =        "Proof Abstraction for Imperative Languages",
  year =         "2006",
  booktitle = "Proceedings of the 4th Asian Symposium
               on Programming Languages and Systems (APLAS06)",
  pages     = {97-113}, 
  abstract = "Modularity in programming language semantics derives from abstracting over
the structure of underlying denotations, yielding semantic descriptions that are more abstract and reusable. One such semantic framework is Liang's modular
monadic semantics in which the underlying semantic structure is encapsulated with a monad. Such abstraction can be at odds with
program verification, however, because program specifications require access to the (deliberately) hidden semantic
representation. The techniques for reasoning about modular monadic definitions of imperative programs introduced here overcome this barrier.
And, just like program definitions in modular monadic semantics, our program specifications and proofs are representation-independent
and hold for whole classes of monads, thereby yielding proofs of great generality.",
}

@inproceedings{harrison06,
  author    = {William L. Harrison},
  title     = {The Essence of Multitasking},
  booktitle = {11th International Conference on Algebraic Methodology
                  and Software Technology {(AMAST 2006)}},
  pages     = {158-172},
  month     = {July},                  
  year      = {2006},
     url_Paper = "https://harrisonwl.github.io/assets/papers/amast06.pdf",
  abstract = "This article demonstrates how a powerful and expressive abstraction from concurrency theory---monads of resumptions---plays a dual r\^{o}le as a programming tool
for concurrent applications.  
The article demonstrates how a
wide variety of typical OS behaviors may be specified in terms of
resumption monads known heretofore exclusively in the literature of 
programming language semantics. 
We illustrate the expressiveness of the resumption monad with the
construction of an exemplary 
multitasking kernel in the pure functional language
Haskell.",
}



@article{ijdmb06,
	Author = {X. Z. Fu and H. Wang and W. Harrison and R. Harrison},
	Title = {{RNA} Pseudoknot Prediction Using Term Rewriting},
	Year = 2005,
  journal =      "International Journal of Data Mining and Bioinformatics",
  abstract = "RNA plays a critical role in mediating every step of cellular information transfer from genes to functional proteins. Pseudoknots are functionally important and widely occurring structural motifs found in all types of RNA. Therefore predicting their structures is an important problem. In this paper, we present a new RNA pseudoknot structure prediction method based on term rewriting. The method is implemented using the Mfold RNA/DNA folding package and the term rewriting language Maude. In our method, RNA structures are treated as terms and rules are discovered for predicting pseudoknots. Our method was tested on 211 pseudoknots in PseudoBase and achieves an average accuracy of 74.085 percent compared to the experimentally determined structure. In fact, most pseudoknots discovered by our method achieve an accuracy of above 90 percent. These results indicate that term rewriting has a broad potential in RNA applications ranging from prediction of pseudoknots to discovery of higher level RNA structures involving complex RNA tertiary interactions."
}

                  
@article{HK05,
  author =       "William L. Harrison and Richard B. Kieburtz",
  title =        "The Logic of Demand in {H}askell",
  journal =      "Journal of Functional Programming",
  volume  = 15,
  number = 6,
  year   = 2005,
  pages = {837-891},
  hjournal = "yes",
   url_Paper = "https://harrisonwl.github.io/assets/papers/jfp05.pdf",
  abstract = "Haskell is a functional programming language whose
                  evaluation is lazy by default. However, Haskell also
                  provides pattern matching facilities which add a
                  modicum of eagerness to its otherwise lazy default
                  evaluation. This mixed or \emph{non-strict}
                  semantics can be quite difficult to reason
                  with. This paper introduces a programming logic,
                  P-Logic, which neatly formalizes the mixed
                  evaluation in Haskell pattern-matching as a logic,
                  thereby simplifying the task of specifying and
                  verifying Haskell programs. In P-Logic, aspects of
                  demand are reflected or represented within both the
                  predicate language and its model theory, allowing
                  for expressive and comprehensible program
                  verification.", 
}

@inproceedings{APLAS05,
     author = "William Harrison",
     title  = "A Simple Semantics for Polymorphic
                  Recursion",
     booktitle = "Proceedings of the 3rd Asian Symposium
                  on Programming Languages and Systems (APLAS05)",
     pages     = {37-51}, 
     month = "November",
     year = 2005,
     address = "Tsukuba, Japan",
     hconf = "yes",
      url_Paper = "https://harrisonwl.github.io/assets/papers/aplas05.pdf",
     abstract = "Polymorphic recursion is a useful extension of Hindley-
Milner typing and has been incorporated in the functional programming
language Haskell. It allows the expression of efficient algorithms
that take advantage of non-uniform data structures and provides key
support for generic programming. However, polymorphic recursion is,
perhaps, not as broadly understood as it could be and this, in part,
motivates the denotational semantics presented here. The semantics reported
here also contributes an essential building block to any semantics
of Haskell: a model for first-order polymorphic recursion. Furthermore,
Haskell-style type classes may be described within this semantic framework
in a straightforward and intuitively appealing manner."
}


@inproceedings{BIBE05,
	Author = {X. Z. Fu and H. Wang and W. Harrison and R. Harrison},
	Booktitle = {Proceedings of IEEE Fifth Symposium on Bioinformatics and
  Bioengineering (BIBE05)},
	Month = {October},
	Title = {{RNA} Pseudoknot Prediction Using Term Rewriting},
	Year = {2005},
	address = "Minneapolis, MN",
	pages = {169-176},
        hconf = "yes",
         url_Paper = "https://harrisonwl.github.io/assets/papers/bibe05.pdf",	
	abstract = "RNA plays a critical role in mediating every step of cellular information transfer from genes to functional proteins. Pseudoknots are widely occurring structural  motifs found in all types of RNA and are also functionally important. Therefore predicting their structures is an important problem. In this paper, we present a new RNA pseudoknot prediction model based on term rewriting rather than on dynamic programming, comparative sequence analysis, or context-free grammars. The model we describe is implemented using the Mfold RNA/DNA folding package and the term rewriting language Maude. Our model was tested on 211 pseudoknots in PseudoBase and achieves an average accuracy of 74.085% compared to the experimentally determined structure. In fact, most pseudoknots discovered by our method achieve an accuracy of above 90%. These results indicate that term rewriting has a broad potential in RNA applications from prediction of pseudoknots to higher level RNA structures involving complex RNA tertiary interactions.",
}

@inproceedings{CSFW05,
	Author = {William Harrison and James Hook},
	Booktitle = {18th IEEE Computer Security Foundations Workshop (CSFW05)},
	Month = {June},
	Title = {Achieving Information Flow Security Through Precise Control of Effects},
	Year = {2005},
	address = "Aix-en-Provence, France",
	pages = {16-30},
        hconf = "yes",
         url_Paper = "https://harrisonwl.github.io/assets/papers/csfw05.pdf",	
	abstract = "This paper advocates controlling information flow and maintaining integrity via monadic encapsulation of effects. This approach is constructive, relying on properties of monads and monad transformers to build, verify, and extend secure software systems. We illustrate this approach by construction of abstract operating systems called separation kernels.",
}



@InProceedings{HarrisonHarrison04,
  author =       "William L. Harrison and Robert W. Harrison",
  title =        "Domain Specific Languages for Cellular Interactions",
  booktitle =    "Proceedings of the 26th Annual IEEE International Conference on Engineering in Medicine and Biology (EMBC04)",
  month =        "September",
  year =         "2004",
  hconf = "yes",
   url_Paper = "https://harrisonwl.github.io/assets/papers/embc04.pdf",
  abstract = "Bioinformatics is the application of Computer Science techniques to problems in Biology, and this paper explores one such application with great potential: the modeling of life cycles of autonomous, intercommunicating cellular systems using domain-specific programming languages (DSLs). We illustrate this approach for the simple photo-synthetic bacterium \emph{R. Sphaeroides} with a DSL called CellSys embedded in the programming language Haskell."
}


@InProceedings{DomSep03,
  author =       "William Harrison and Mark Tullsen and James Hook",
  title =        "Domain Separation by Construction",
  booktitle =    "LICS03 Satellite Workshop on Foundations of Computer Security (FCS03)",
  month =        "June",
  year =         "2003",
  note = "21 pages",
  hconf = "yes",
   url_Paper = "https://harrisonwl.github.io/assets/papers/fcs03.pdf",
  abstract = "This paper advocates a novel approach to language-based security: by structuring software with monads (a form of abstract data type for effects), we are able to maintain separation of effects by construction. The thesis of this work is that well-understood properties of monads and monad transformers aid in the construction and verification of secure software. We introduce a formulation of non-interference based on monads rather than the typical trace-based formulation. Using this formulation, we prove a non-interference style property for a simple instance of our system model. Because monads may be easily and safely represented within any pure, higher-order, typed functional language, the resulting system models may be directly realized within such a language.",
}


@InProceedings{HK02,
   author = "William Harrison and Richard Kieburtz",
   title  = "Pattern-driven Reduction in Haskell",
   booktitle = "2nd International Workshop on Reduction Strategies in Rewriting and Programming (WRS02)",
   address = "Copenhagen, Denmark",
   year  = "2002",
   hconf = "yes",
    url_Paper = "https://harrisonwl.github.io/assets/papers/wrs02.pdf",
   abstract = "Haskell is a functional programming language with nominally non-strict
semantics, implying that evaluation of a Haskell expression proceeds by
demand-driven reduction.  However, Haskell also provides pattern 
matching
on arguments of functions, in {\bf let} expressions and in the match
clauses of {\bf case} expressions.  Pattern-matching requires
data-driven reduction to the extent necessary to
evaluate a pattern match or to bind variables introduced in a pattern.
In this paper we
provide both an abstract semantics and a logical characterization of
pattern-matching in Haskell and the reduction order that it entails.",
}



@InProceedings{FCDH2002,
  author =       "William Harrison and Timothy Sheard and James Hook",
  title =        "Fine Control of Demand in {Haskell}",
  booktitle =    "6th International Conference on the Mathematics of
                 Program Construction (MPC02),
                 Dagstuhl, Germany",
  year =         "2002",
  publisher =    "Springer-Verlag",
  volume =       "2386",
  pages =        "68--93",
  series =       "Lecture Notes in Computer Science",
  hconf = "yes",
   url_Paper = "https://harrisonwl.github.io/assets/papers/mpc02.pdf",
  abstract = "Functional languages have the lambda calculus at their core, but then depart from this firm foundation by including features that alter their default evaluation order. The resulting mixed evaluation---partly lazy and partly strict---complicates the formal semantics of these languages. The functional language Haskell is such a language, with features such as pattern-matching, case expressions with guards, etc., introducing a modicum of strictness into the otherwise lazy language. But just how does Haskell differ from the lazy lambda calculus? We answer this question by introducing a calculational semantics for Haskell that exposes the interaction of its strict features with its default laziness. In the semantics, features perturbing Haskell's standard lazy evaluation order are specified computationally (i.e., monadically) rather than as pure values (i.e., functions, scalars, etc.)."
}



@InProceedings{HarrisonSheard2001,
  author =       "Bill Harrison and Tim Sheard",
  title =        "Dynamically Adaptable Software with Metacomputations in a Staged Language",
  journal =      "Lecture Notes in Computer Science",
  booktitle =    "Proceedings of the Second International Workshop on
                  Semantics, Applications, and Implementation of Program Generation (SAIG)",
  address =      "Florence, Italy", 
  volume =       "2196",
  pages =        "163--182",
  publisher =    "Springer-Verlag",
  series =       "Lecture Notes in Computer Science",
  year =         "2001",
  hconf = "yes",
   url_Paper = "https://harrisonwl.github.io/assets/papers/saig01.pdf",
  abstract = "Profile-driven compiler optimizations take advantage of information gathered at runtime to re-compile programs into more efficient code. Such optimizations appear to be more easily incorporated within a semantics-directed compiler structure than within traditional compiler structure. We present a case study in which a metacomputation-based reference compiler for a small imperative language converts easily into a compiler which performs a particular profile-driven optimization: local register allocation. Our reference compiler is implemented in the staged, functional language MetaML and takes full advantage of the synergy between metacomputation-style language definitions and the staging constructs of MetaML. We believe that the approach to implementing profile-driven optimizations presented here suggests a useful, formal model for dynamically adaptable software.",
}

@PhdThesis{Harrison2001,
  author =       "William Harrison",
  title =        "Modular Compilers and Their Correctness Proofs",
  year =         "2001",
  school =       "University of Illinois at Urbana-Champaign",
  hthesis = "yes",
   url_Paper = "https://harrisonwl.github.io/assets/papers/dissertation.pdf",
  abstract = "This thesis explores the construction and correctness of modular compilers. Modular compilation is a compiler construction technique allowing the construction of compilers for high-level programming languages from reusable compiler building blocks. Modular compilers are defined in terms of denotational semantics based on monads, monad transformers, and a new model of staged computation called metacomputations. A novel form of denotational specification called observational program specification and related proof techniques are developed to assist in modular compiler verification. It will be demonstrated that the modular compilation framework provides both a level of modularity in compiler proofs as well as a useful organizing principle for such proofs.",
}





@InProceedings{HarrisonKamin2000,
  author =       "William Harrison and Samuel Kamin",
  title =        "Metacomputation-based Compiler Architecture",
  booktitle =    "5th International Conference on the Mathematics of
                 Program Construction,
                 Ponte de Lima, Portugal",
  year =         "2000",
  publisher =    "Springer-Verlag",
  volume =       "1837",
  pages =        "213--229",
  series =       "Lecture Notes in Computer Science",
  hconf = "yes",
   url_Paper = "https://harrisonwl.github.io/assets/papers/mpc00.pdf",
  abstract = "This paper presents a modular and extensible style of language specification based on metacomputations. This style uses two monads to factor the static and dynamic parts of the specification, thereby staging the specification and achieving strong binding-time separation. Because metacomputations are defined in terms of monads, they can be constructed modularly and extensibly using monad transformers. Consequently, metacomputation-style specifications are modular and extensible. A number of language constructs are specified: expressions, control-flow, imperative features, block structure, and higher-order functions and recursive bindings. Because of the strong binding-time separation, metacomputation-style specification lends itself to semantics-directed compilation, which we demonstrate by creating a modular compiler for a block-structured imperative, while language.",
}


@InProceedings{HarrisonKamin1998,
  author =       "William L. Harrison and Samuel N. Kamin",
  title =        "Modular Compilers Based on Monad Transformers",
  booktitle =    "Proceedings of the 1998 International Conference on
                 Computer Languages",
  publisher =    "IEEE Computer Society Press",
  year =         "1998",
  ISBN =         "0-780-35005-7, 0-8186-8454-2, 0-8186-8456-9",
  pages =        "122--131",
  hconf = "yes",
   url_Paper = "https://harrisonwl.github.io/assets/papers/iccl98.pdf",
  abstract =     "The monadic style of language specification has the
                 advantages of modularity and extensibility: it is
                 simple to add or change features in an interpreter to
                 re ect modifications in the source language. It has
                 proven difficult to extend the method to compilation.
                 We demonstrate that by introducing machine-like stores
                 (code and data) into the monadic semantics and then
                 partially evaluating the resulting semantic
                 expressions, we can achieve many of the same advantages
                 for a compiler as for an interpreter. A number of
                 language constructs and features are compiled:
                 expressions, CBV and CBN evaluation of
                 $\lambda$-expressions, dynamic scoping, and various
                 imperative features. The treatment of recursive
                 procedures is outlined as well. The resulting method
                 allows compilers to be constructed in a mix-and-match
                 fashion just as in a monad-structured interpreter.",
}

@MastersThesis{Harrison1992,
  author =       "William Harrison",
  title =        "Mechanizing the Axiomatic Semantics for a Programming Language with Asynchronous Send and Receive in HOL",
  year =         "1992",
  school =       "University of California, Davis",
  hthesis = "yes",
   url_Paper = "https://harrisonwl.github.io/assets/papers/masters-thesis.pdf",
  abstract = "This thesis presents the axiomatic semantics for a simple distributed language and its mechanization in HOL. The constructs of this language include asynchronous send and synchronous receive statements as well as those basic to a sequential programming language. The language has the appearance of a system programming language that supports sequential execution extended with message-passing, and would be a suitable basis for coding distributed operating systems. Included in the mechanization are functions which generate the goals associated with the verification of simple statements in the language.",
}

  


@InProceedings{harrison92,
  author =       "William Harrison and Karl Levitt and Myla Archer",
  title =        "An HOL Mechanization of the Axiomatic Semantics of a Simple
Distributed Programming Language",
  booktitle =    "Proceedings of the International Workshop on Higher-Order Logic
  Theorem Proving and Its Applications",
  month = "September",
  address = "Leuven, Belgium",
  year =         "1992",
  pages =        "347-358",
  hconf = "yes",
  abstract = "",
}


@INPROCEEDINGS{MeSeHOL,
  AUTHOR = {William Harrison and Karl Levitt},
  TITLE = {Mechanizing Security in {HOL}},
  BOOKTITLE = {Proceedings of the 1991 International Workshop
            on the {HOL} Theorem Proving System and its Applications},
  PUBLISHER = {IEEE Computer Society Press},
  YEAR = {1991},
  PAGES = {63--66},
  address = "Davis, California",
  hconf = "yes",
  abstract = "",
}


@TechReport{tr92a,
  author = 	 {William Harrison and Karl Levitt and Myla Archer},
  title = 	 {{Towards a Verified Code Basis for a Secure Distributed Operating System}},
  institution =  {University of California at Davis},
  number =       "CSE-92-19",
  year = 	 1992,
  htr =          "yes",
}

@TechReport{tr92b,
  author = 	 {William Harrison},
  title = 	 {{Mechanizing the Axiomatic Semantics for a Programming Language with Asynchronous Send and Receive in HOL}},
  institution =  {University of California at Davis},
  number =       "CSE-92-20",
  year = 	 1992,
  htr =          "yes",
}
